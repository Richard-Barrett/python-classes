<!DOCTYPE html>
<html>
  <head>
    <title>Title</title>
    <meta charset="utf-8">
    <link rel="stylesheet" type="text/css" href="koder.css">
  </head>
  <body>
    <textarea id="source">

<!---------------------------------------------------------------------------->

???
* В CPU много ядер, в компьютере много CPU
* Память или с общим доступом или NUMA, ресурсы шаренные
* Процессы
* MPI, OpenMP, parallel-python, ....
* hadoop/spark
* multiprocessing


---
```python
import multiprocessing

def worker():
    """worker function"""
    print 'Worker'
    return

if __name__ == '__main__':
    jobs = []
    for i in range(5):
        p = multiprocessing.Process(target=worker)
        jobs.append(p)
        p.start()
```

---

```python
from mpi4py import MPI

comm = MPI.COMM_WORLD
rank = comm.Get_rank()

if rank == 0:
    data = {'a': 7, 'b': 3.14}
    req = comm.isend(data, dest=1, tag=11)
    req.wait()
elif rank == 1:
    req = comm.irecv(source=0, tag=11)
    data = req.wait()
```

???
* закон амдала
* синхронизация
* барьеры
* Чуть больше ресурсов
* Часть задач общая и она дублируется
* Обмен данными медленный (однако OpenMP)
* Часть этих проблем можно обойти на системе с общей памятью

---

???

* потоки (потоки владеют стеком)
* множество потоков исполнения
* ядра процессоров - отдельные процессоры (*почти)

---

```python
import threading

def worker():
    """thread worker function"""
    print('Worker from thread', threading.current_thread().ident)
    return

threads = []
for i in range(5):
    t = threading.Thread(target=worker)
    threads.append(t)
    t.start()

for th in threads:
    t.join()
```

---
```
Worker from thread 139690361517824
Worker from thread 139690084742912
Worker from thread 139690076350208
Worker from thread 139690084742912
Worker from thread 139690076350208
````
---
???

Проблемы потоков

* разделяемые ресурсы
* зависания
* потеря исключений
* усложнение отладки
* усложнение тестировани

---
```python

def add(var, x):
    v = var.get_val()
    v += x
    var.set_val(v)
```
???

* все, что потоки разделяют
* глобальные переменные
* статические переменные
* mock и другие хаки
* thread safe

---

???
sync primitives

* Lock(mutex)

---
Использование блокировок
```python

from threading import Lock

def add(var, x, lock):
    lock.acquire()
    v = var.get_val()
    v += x
    var.set_val(v)      
    lock.release()
```

---
```python

def add(var, x, lock):
    lock.acquire()
    try:
        v = var.get_val()
        v += x
        var.set_val(v)      
    finally:
        lock.release()

l = Lock()
v = Var(1)
add(l, v, 1)

```
---
```python

def add(var, x, lock):
    with lock:
        v = var.get_val()
        v += x
        var.set_val(v)      

l = Lock()
v = Var(1)
add(l, v, 1)

```

---
```python

from threading import Lock

class Var:
    def __init__(self, v):
        self.lock = Lock()
        self.v = v

    def __enter__(self):
        self.lock.acquire()

    def __exit__(self, x, y, z):
        self.lock.release()


def add(var, x):
    # with var.lock:
    with var:
        v = var.get_val()
        v += x
        var.set_val(v)      

v = Var(1)
add(l, v, 1)

```

---
```python

from threading import Condition

########### Consumer ##################### 
v = SomeCls()
cv = Condition()  # lock
with cv:
    while not v.ready():
        cv.wait()
    do_work(v)      

########### Producer ##################### 

with cv:
    v.set_ready()
    cv.notify()  # 1
    cv.notify_all()

```

---

* Semafore
* RLock
* Barrier
* Event

* CriticalSection
* RWLock

---

???
issues

* не захватили блокировку
* не освободили блокировку
* гонка
* дедлок
* инверсия приоритетов

---
```python

def get_sum(x1: LockedIntVar, x2: LockedIntVar):
    with x1:
        v = x1.val()

    with x2:
        retrun v + x2.val()


def move(x1: LockedIntVar, x2: LockedIntVar, delta: int):
    with x1:
        x1.add(delta)

    with x2:
        x2.add(-delta)

```

---
```python

def get_sum(x1: LockedIntVar, x2: LockedIntVar):
    with x1:
        v = x1.val()

    with x2:
        retrun v + x2.val()


def move(x1: LockedIntVar, x2: LockedIntVar, delta: int):
    with x1:
        with x2:
            x1.add(delta)
            x2.add(-delta)
```

---

* Захват блокировки снаружи vs захват блокировки внутри

???

* Захват только одной блокировки
* Внутри захваченной блокировки не вызываются функции, либо вызыватся простые

---
План:
* Гранулярность блокировки vs. уровень параллелизма
* однопоточный код + блокировки - много потоков
* симметричные функции потоков в ассиметричные
* вынос IO в отдельный pool с очередью ответов + отдельный пул для CPU intencive на футурес + центральный поток воркетор
* queue-based CSP, erlang/go/scala+akka/stackless python
* функциональный стиль и многопоточность
* три типа потоков - логика, io-bounded, cpu-bounded

---
```python

l1 = Lock()


def f1():
    x = 1
    ...
    with l1:
        some_var += x


def f2():
    with l1:
        some_var *= 2

    ...

    with l1:
        r = some_var

    r ...
```
???

* Давайте переформатируем этот код
* вынесем куски под локом в отдельные функции 
* Фактически этот код однопоточен
---

```python

def f1_l(x):
    some_var += x

def f2_1()
    some_var *= 2

def f2_2()
    return some_var

def f1():
    x = 1
    ...
    f1_1(x)


def f2():
    f2_1()
    ...

    r = f2_2()

    r ...
```

---
```python

def some_var_func(q):
    some_var = 1
    while True:
        msg, param = q.get()
        if msg == '1':
            some_var += param
        elif msg == '2':
            assert param is None
            some_var *= 2
        elif msg == '3'
            assert isinstance(param, Queue)
            param.put(some_var)
```

---
```python

def f1():
    x = 1
    ...
    some_var_q.put(('1', x))


def f2():
    some_var_q.put(('2', None))
    ...

    q = Queue()
    some_var_q.put(('3', q))
    r = q.get()

    r ...

```

???
* Один лок - один потом + очередь
* скорость - ок
* чуть больше кода, но мы избавились от блокировок (*почти)
* возможна ситуация, когда два потока висят, ожидая друг друга
---

Communicating sequential processes

* нет общих данных
* потоки обмениваются сообщениями через очереди
* queues

---

* workers

---
threadpools
Для обработки задач, которые не требуют коммуникации посередине
Универсальная модель - 0 дата шаринг, функция + данные
Лимит на количество потоков

---
futures
"будущее" значение

---

???
* GIL
* GIL removal
* GIL release
* etc
* python thread execution scheme
---

* Паттерны и примеры

???

* web scapper всеми способами
* Сначала однопоточный
* Потом 

---
```python
class IURLStor:
    @abc.abstractmethod
    def store(self, url: str, content: str):
        pass

def mirror_urls(start_urls: List[str], storage: IURLStor)
    pass

```

---
```python
class IURLStor:
    @abc.abstractmethod
    def store(self, url: str, content: str):
        pass

def mirror_urls(start_urls: List[str], stor: Callable[[str, str]])
    pass

mirror_urls(urls, storage.store)

```

---
concurrency is not parallelism
https://www.youtube.com/watch?v=cN_DpYBzKso

---
    </textarea>
    <script src="js/remark-latest.min.js" type="text/javascript"></script>
    <script src="js/MathJax.js" type="text/javascript"></script>
    <script type="text/javascript">
      var slideshow = remark.create({highlightStyle: 'dracula', ratio: '16:9'});

      // Setup MathJax
      MathJax.Hub.Config({
          tex2jax: {
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre']
          }
      });

      MathJax.Hub.Configured();
    </script>
  </body>
</html>