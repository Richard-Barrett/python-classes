% python classes slides - introduction
% (c) 2012 Kostiantyn Danylov aka koder 
% koder.mail@gmail.com
% distributed under CC-BY licence
% http://creativecommons.org/licenses/by/3.0/deed.en

\documentclass{article}
\input{files/lectures_env}
\input{files/python_cmds}
\begin{document}
\LARGE

%-------------------------------------------------------------------------------
\begin{center} HW \end{center}
\begin{itemize}
    \item Установить Python
    \item Создать виртуальное окружение для python, 
            вся дальнейшая работа будет идти из него
    \item Установить ipython (со всеми зависимостями)
    \item ipython qtconsole, ipython notebook
    \item аккаунт на pikacode + mercurial + TortoiseHG
    \item или аккаунт на github + git (привет, windows!)
    \item sublime text 2 / notepad++ / vim / emacs /eclipse + pydev
    \item Найти и прочитать pep8
    \item \lstinline!import this! - the Zen of Python
    \item pep8 + pylint
    \item winpdb
    \item \href{http://koder-ua.blogspot.com/2012/09/blog-post.html}{Более подробное описание}
\end{itemize}
\newpage

%-------------------------------------------------------------------------------
\begin{center} AI \end{center}
\begin{itemize}
  \item Прочитать описание строковых операций
  \item Прочитать описание format
  \item \href{http://www.youtube.com/watch?feature=player_embedded&v=sgHbC6udIqc}{Pragmatic Unicode, or, How do I stop the pain?}
  \item \href{http://www.youtube.com/watch?v=kWyoYtvJpe4}{Google Python Class Day 2 Part 1: regular exression}
\end{itemize}


%-------------------------------------------------------------------------------
\begin{center} Разложить число на простые делители \end{center}
Написать функцию factorize, которая возвращает все простые делители
у переданного числа.
\newpage

%-------------------------------------------------------------------------------
\begin{center} Декодирование АОН \end{center}
\begin{itemize}
    \item Нужно преобразовать строку по следующим правилам:
    \item Если   символ идет 2 и больше раз подрят - записать его в результат 1 раз
    \item Если символ повторяется 1 раз - отбросить
    \item Если \# повторяется два и более раз - последний символ, записанный в результт записать еще раз
    \item "" => ""
    \item "1" => ""
    \item "11" => "1"
    \item "11111" => "1"
    \item "11\#" => "1"
    \item "11\#\#" => "11"
    \item "11122234\#\#\#55" => "1225"
\end{itemize}
\newpage

%------------------------------------------------------------------------------
\begin{center}
\href{http://ru.wikipedia.org/wiki/%D0%93%D0%BD%D0%BE%D0%BC%D1%8C%D1%8F_%D1%81%D0%BE%D1%80%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B0}{Гномья сортировка}
\end{center}

Сравниваются соседние элементы. Если они неупорядоченны - они меняются местами и делается шаг назад.
Если они упорядоченны, то шаг вперед. Если дошли до конца, то сортировка оконченна.
\newpage

%------------------------------------------------------------------------------
\begin{center} Двоичный поиск \end{center}
Найти елемент в упорядоченном массиве методом дихотомии.
\newpage

%------------------------------------------------------------------------------
\begin{center} Кодирование Шеннона — Фано \end{center}
\begin{itemize}
    \item 
    \item Сообщение бъется на элементы
    \item Изначально коды для всех элементов пустые
    \item Элементы множества выписывают в порядке убывания вероятностей.
    \item Множество делится на две части, суммарные вероятности символов которых
            максимально близки друг другу.
    \item К коду первой половины элементов дописывается "0", второй "1"
    \item Алгоритм повторяется для обоих частей
\end{itemize}
\newpage

%------------------------------------------------------------------------------
\begin{center}Кодирование и декодирование файла по Хаффману.\end{center}
На диске есть файл с именем "input.txt". Его нужно прочитать, закодировать символы 
использую не адаптивный алгоритм 
\href{http://ru.wikipedia.org/wiki/%D0%9A%D0%BE%D0%B4_%D0%A5%D0%B0%D1%84%D1%84%D0%BC%D0%B0%D0%BD%D0%B0}{Хаффмана} 
и записать результат в 
output.bin. В решении должно быть две функции 
hf\_encode(string) str->str, и hf\_decode(string) str->str. Первая кодирует, вторая декодирует. 
Входными элементами для алгоритма являются отдельные байты файла.
\newpage

%------------------------------------------------------------------------------
\begin{center} Интерпретатор minilisp \end{center}
Программа на mini-lisp имеет вид (oper param1 param2 para3 .... paramn),
здесь oper это имя функции - любой набор символов, кроме пробелов.
param2 - целое, строка в кавычках (без кавычек внутри) или другая программа на mini-lisp.
Допустимые oper - '+' (складывает все операнды), '-' (вычитает из первого все операнды), 
print (печатает все операнды через пробел). Сложение имеет такой же смысл, как и в питоне. 
Вычитание для строк не определено. Нужно написать функция eval\_minilisp, которая 
исполнить программу переданную параметром. 
По умолчанию из main вызывать eval\_minilisp("example.lst")

\begin{itemize}
    \item \lstinline!eval_minilisp('(+ 1 2 3)')! должна вернуть 6
    \item \lstinline!eval_minilisp('(print (+ "a" "bc"))')! => должны напечатать 'abc'
\end{itemize}
\newpage

%------------------------------------------------------------------------------

\begin{center} интерпретатор подмножества языка forth \end{center}

      Программа на Forth состоит из набора команд(слов),
      некоторые из которых имеют параметры. Для хранения данных используется стек -
      команды получают свои операнды с вершины стека и туда же сохраняют результаты.
      В  подмножестве 5 команд:

\begin{itemize}
    \item put значение - помещает значение в стек. Значение может
          быть числом или строкой. Строка заключается в кавычки, внутри
          строки кавычек быть не может.
    \item pop - убирает значение из стека
    \item add - убирает из стека 2 значения, складывает их и помещает результат в стек
    \item sub - убирает из стека 2 значения, вычитает их и помещает результат в стек
    \item print - вынимает из стека 1 значение и печатает его.
\end{itemize}


\begin{lstlisting}
  put 3
  put "asdaadasdas"
\end{lstlisting}

      Каждая команда начинается с новой строки. Строки, начинающиеся с '\#' - комментарии.
      Ваша программа должна содержать функцию eval\_forth(), принимающую строку на языке
      forth и исполняющую ее. По умолчанию из main вызывать eval\_forth("example.frt")
      Пример, если в example.rft будет:

\begin{lstlisting}
  put 1
  put 3
  add
  print
\end{lstlisting}

      То программа должна напечатать '4'. 

  Сложение имеет такой же смысл, как и в питоне. Вычитание для строк не определено
  Программа должна содержать функцию eval\_forth(), принимающую строку на языке forth и исполняющую ее. 
  По умолчанию из main вызывать eval\_forth("example.frt")
\newpage

%------------------------------------------------------------------------------
\begin{center} строковые функции \end{center}
Написать строковые функции xfind, xreplace, xsplit, xjoin используя
срезы строк (без применения других методов строк).
\begin{itemize}
    \item xfind(s1, s2) == s1.find(s2)
    \item xreplace(s1, s2, s3) == s1.replace(s2, s3)
    \item xsplit(s1, s2) == s1.split(s2)
    \item xjoin(s, array) == s.join(array)
\end{itemize}
\newpage

%------------------------------------------------------------------------------
\begin{center} Умножение больших чисел \end{center}
Реализовать алгоритм 
\href{http://ru.wikipedia.org/wiki/%D0%A3%D0%BC%D0%BD%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D0%B5_%D0%9A%D0%B0%D1%80%D0%B0%D1%86%D1%83%D0%B1%D1%8B}
{Карацубы} 
для умножения больших чисел.
$AB * CD == (A + B * 2^m) * (C + D * 2^m) 
         = A * C + 2^{2*m} * B * D + 2^m * (B * C + A * D)
         = A * C + 2^{2*m} * B * D + 2^m * ((A + B)(C + D) – A * C - B * D) $
\newpage

%------------------------------------------------------------------------------
\begin{center} Острова \end{center}
Задан двумерный массив из {0,1}. Островом называется связная группа единиц,
т.е. такие что от любой из них можно дойти до любой другой, перемещаюсь за шаг
на одну клетку вверх, вниз, вправо, влево или по диагонали и не попадая на 
клетки с '0'. Посчитать количество островов.
\newpage

%------------------------------------------------------------------------------
\begin{center} FP \end{center}
Написать функции:
\begin{itemize}
    \item my\_map, принимает функцию и список, 
            возвращяет список полученный в итоге применения переданной функции 
            к каждому элементу из списка-параметра. 
            \lstinline!map(func, lst) == [func(lst[0]), func(lst[1]), ..., func(lst[N])]!
    \item my\_filter(func, lst1) -> lst2. lst2 содержит только те элементы из lst1,
          для которых func возвращает True
    \item my\_reduce(my\_fold) 
\href{http://ru.wikipedia.org/wiki/%D0%A1%D0%B2%D1%91%D1%80%D1%82%D0%BA%D0%B0_%D1%81%D0%BF%D0%B8%D1%81%D0%BA%D0%B0}{описание reduce}.
    \item рекурсивные варианты всех этих функций
    \item Функцию bind, которая принимает функцию func и список параметров params1
          и возвращает функцию, при вызове которой со списком параметров params2 вызывается
          func c объединенным списком параметров params1 + params2.
          То-же, но с поддержекой именованных аргументов.
          \lstinline!bind(func, 1, 2, "3")(2, 4) == func(1, 2, "3", 2, 4)!
    \item my\_map\_gen, my\_filter\_gen, my\_reduce\_gen, которые принимают генераторы и возвращают генераторы
\end{itemize}
\newpage

%------------------------------------------------------------------------------
\begin{center} super \end{center}
Написать my\_super, аналогичный по поведению встроенному 
\newpage

%------------------------------------------------------------------------------
\begin{center} Oбработка файла \end{center}
Написать конвеерные генераторы для обработки тектовых потоков.
\begin{itemize}
    \item iter\_lines(fd) получает имя файла итерирует по строкам. 
           Для чтения можно использовать только fd.read(1)
    \item strip\_spaces(iter) -> принимает итератор, получает из него 
          строки и возвращает строки без стартовых и финальных пробельных символов
    \item drop\_empty - получает итератор и возвращает только не пустые строки
    \item split\_items - получает итератор, считывает из него строки, 
          разбивает их по пробелам и для каждого элемента определяет является ли он
          строковым представлением целого или числа с плавающей запятой.
          Приводит опознанные елементы к int/float соответсвенно, остальные оставляет
          строками. Возращает итератор по этим элементам
    \item get\_ints - возращает из входного потока только целые
    \item my\_sum - считает сумму элементов целых во входном потоке
\end{itemize}

\begin{lstlisting}
    # fd == "1 2 3 3.45 abra_cadabra   \n\n12"
    list(iter_lines(fd)) == \
        ["1 2 3 3.45 abra_cadabra   ", "", "12"]
    list(strip_spaces(iter_lines(fd))) == \
        ["1 2 3 3.45 abra_cadabra", "", "12"]
    list(drop_empty(["1 2 3 3.45 abra_cadabra", "", "12"])) == \
        ["1 2 3 3.45 abra_cadabra", "12"]
    list(split_items(["1 2 3 3.45 abra_cadabra", "12"])) == \
        [1, 2, 3, 3.45, "abra_cadabra", 12]
    list(get_ints([1, 2, 3, 3.45, "abra_cadabra", 12])) == \
        [1, 2, 3, 12]
    my_sum([1, 2, 3, 12]) == 18

    my_sum(get_ints(drop_empty(strip_spaces(iter_lines(fd))))) == 18
\end{lstlisting}

\newpage

%------------------------------------------------------------------------------
\begin{center}Сайт на CherryPy\end{center}
\href{http://www.cherrypy.org/}{CherryPy} это библиотека для написания простых веб приложений.
Необходимо написать иерархию классов для сайта. 
\begin{itemize}
    \item Пустой класс Router
    \item Класс BaseSite с методом index, который возвращает "Hello"
    \item Класс PolliteSite, наследующий BaseSite, имеющий метод set\_name,
            принимающий имя в качестве параметра.
            В методе index он должен возвращать "Hello" + name. name по умолчанию пустое.
    \item Класс StructuredSite от PolliteSite, который добавляет два метода - header и footer.
          Заголовок и подложка, которые должны выводиться вверху и внизу каждой страници.
          По умолчанию он пишет в footer текущее время (модуль datetime). А в header - 
          "name {текущщее имя пользователя}".

\end{itemize}

CherryPy привращает HTTP запрос (та строка, которую вы вводите в адресной строке браузера)
вида http://domain/x/y/z?var1=val1\&var2=val2
в вызов RootObject.x.y.z(var1=val1, var2=val2) или в вызов \\
RootObject.x.y.z.index(var1=val1, var2=val2) в зависимости от того, что есть.

\begin{lstlisting}
  import cherrypy

  class Router(object):
      pass

  Router.base = BasicSite()
  Router.pollite1 = PolliteSite()
  Router.pollite2 = PolliteSite()

  cherrypy.quickstart(HelloWorld())
\end{lstlisting}

Запускаем эту программу, запускаем браузер и вводим в адресной строке '127.0.0.1:8080'.

\newpage

%-------------------------------------------------------------------------------
{\center Задание - func\_info}
    Написать функцию func\_info, которая принимает функцию и печатает ее
    \begin{itemize}
        \item Имя
        \item Количество параметров
        \item Документацию
        \item Значения параметров по умолчанию
        \item Поля искать через ipython/google/\href{http://docs.python.org/reference/datamodel.html}{python doc}
    \end{itemize}
\newpage
%-------------------------------------------------------------------------------
\begin{center}Задание - композиция функций\end{center}
  Написать функцию haskell\_dot, которая принимает неограниченное количество функций
  и возвращает новую функцию, поторая при вызове последовательно применяет все 
  сохраненные функции к параметру. \\

  haskell\_dot(f1, f2, f3, ....) -> fC \\
  fC(x) = f1(f2(f3(...(x))))
\newpage


%------------------------------------------------------------------------------
\begin{center} web crawler \end{center}
\newpage

%------------------------------------------------------------------------------
\begin{center} Алгоритм Кнута-Морриса-Пратта \end{center}
\begin{itemize}
    \item 
\end{itemize}
\newpage

%-----------------------------------------------------------------------------
\begin{center} Тетрис \end{center}
ООП, сделать GUI - заготовку
\newpage

%------------------------------------------------------------------------------
\begin{center} subprocess \end{center}
traceroute - получить путь
tcpdump - подсчет данных на соединении
\newpage

%------------------------------------------------------------------------------
\end{document}
%------------------------------------------------------------------------------
% http://acm.mipt.ru/judge/problems.pl?psorto=compl~d&CGISESSID=660ae15a1fa989f66471c7b094375452
% http://codegolf.stackexchange.com/
% http://informatics.mccme.ru/moodle/ - много задач, но в основном слабые
