% python classes slides - tasks
% (c) 2012 Kostiantyn Danylov aka koder 
% koder.mail@gmail.com
% distributed under CC-BY licence
% http://creativecommons.org/licenses/by/3.0/deed.en

\documentclass{article}
\input{files/lectures_env}
\input{files/python_cmds}
\begin{document}
\LARGE

%------------------------------------------------------------------------------
\begin{center} Преобразование в польскую нотацию \end{center}
\newpage

%------------------------------------------------------------------------------
\begin{center} Функтор \end{center}
1) Написать объект, который запоминает арифметические операции, проделанные над ним 
и может их повторить.
2) Написать объект, который трансформирует операции сравнения над собой в WHERE для SQL.

\begin{lstlisting}
    x = Var()
    f = 3 * x + x ** 2
    f(1) == 4

    y = SQL("table.field")
    str(y > 12 && y != 17)  == "table.field > 12 AND table.field != 17"
\end{lstlisting}
\newpage

%------------------------------------------------------------------------------
\begin{center}
\href{http://ru.wikipedia.org/wiki/%D0%93%D0%BD%D0%BE%D0%BC%D1%8C%D1%8F_%D1%81%D0%BE%D1%80%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B0}{Гномья сортировка}
\end{center}
В массиве сравниваются соседние элементы. 
Если они неупорядоченны - они меняются местами и делается шаг назад.
Если они упорядоченны, то шаг вперед. 
Если дошли до конца, то сортировка оконченна.
\newpage

%------------------------------------------------------------------------------
\begin{center} Кодирование Шеннона — Фано \end{center}
\begin{itemize}
    \item Сообщение бъется на элементы
    \item Изначально коды для всех элементов пустые
    \item Элементы множества выписывают в порядке убывания вероятностей.
    \item Множество делится на две части, суммарные вероятности символов которых
            максимально близки друг другу.
    \item К коду первой половины элементов дописывается "0", второй "1"
    \item Алгоритм повторяется для обоих частей
\end{itemize}
\newpage

%------------------------------------------------------------------------------
\begin{center}Кодирование и декодирование файла по Хаффману.\end{center}
На диске есть файл с именем "input.txt". Его нужно прочитать, закодировать символы 
используя не адаптивный алгоритм 
\href{http://ru.wikipedia.org/wiki/%D0%9A%D0%BE%D0%B4_%D0%A5%D0%B0%D1%84%D1%84%D0%BC%D0%B0%D0%BD%D0%B0}{Хаффмана}  и записать результат в 
output.bin. В решении должно быть две функции 
hf\_encode(string) str->str, и hf\_decode(string) str->str. 
Первая кодирует, вторая декодирует. 
Входными элементами для алгоритма являются отдельные байты файла.
\newpage

%------------------------------------------------------------------------------
\begin{center} Интерпретатор minilisp \end{center}
Программа на mini-lisp имеет вид (oper param1 param2 para3 .... paramn),
здесь oper это имя функции - любой набор символов, кроме пробелов.
param2 - целое, строка в кавычках (без кавычек внутри) или другая программа на mini-lisp.
Допустимые oper - '+' (складывает все операнды), '-' (вычитает из первого все операнды), 
print (печатает все операнды через пробел). Сложение имеет такой же смысл, как и в питоне. 
Вычитание для строк не определено. Нужно написать функция eval\_minilisp, которая 
исполнить программу переданную параметром. 
По умолчанию из main вызывать eval\_minilisp("example.lst")

\begin{itemize}
    \item \lstinline!eval_minilisp('(+ 1 2 3)')! должна вернуть 6
    \item \lstinline!eval_minilisp('(print (+ "a" "bc"))')! => должны напечатать 'abc'
\end{itemize}
\newpage

%------------------------------------------------------------------------------
\begin{center} Интерпретатор minilisp с промежуточным деревом \end{center}
\begin{itemize}
    \item Сделать задание "Интерпретатор minilisp" но промежуточно необходимо преобразовать
        дерево в форму, удобную для промежуточной обработки. 
    \item Сделать систему разбора расширяемой снаружи новыми командами.
\end{itemize}
\newpage

%------------------------------------------------------------------------------
\begin{center} интерпретатор подмножества языка forth \end{center}
      Программа на Forth состоит из набора команд(слов),
      некоторые из которых имеют параметры. Для хранения данных используется стек -
      команды получают свои операнды с вершины стека и туда же сохраняют результаты.
      В  подмножестве 5 команд:
\begin{itemize}
    \item put значение - помещает значение в стек. Значение может
          быть числом или строкой. Строка заключается в кавычки, внутри
          строки кавычек быть не может.
    \item pop - убирает значение из стека
    \item add - убирает из стека 2 значения, складывает их и помещает результат в стек
    \item sub - убирает из стека 2 значения, вычитает их и помещает результат в стек
    \item print - вынимает из стека 1 значение и печатает его.
\end{itemize}


\begin{lstlisting}
    put 3
    put "asdaadasdas"
\end{lstlisting}

    Каждая команда начинается с новой строки. Строки, начинающиеся с '\#' - комментарии.
    Ваша программа должна содержать функцию eval\_forth(), принимающую строку на языке
    forth и исполняющую ее. По умолчанию из main вызывать eval\_forth("example.frt")
    Пример, если в example.rft будет:

\begin{lstlisting}
    put 1
    put 3
    add
    print
\end{lstlisting}

    То программа должна напечатать '4'. 

    Сложение имеет такой же смысл, как и в питоне. Вычитание для строк не определено
    Программа должна содержать функцию eval\_forth(), принимающую строку на языке forth и исполняющую ее. 
    По умолчанию из main вызывать eval\_forth("example.frt")
\newpage

%------------------------------------------------------------------------------
\begin{center} Умножение больших чисел \end{center}
Реализовать алгоритм 
\href{http://ru.wikipedia.org/wiki/%D0%A3%D0%BC%D0%BD%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D0%B5_%D0%9A%D0%B0%D1%80%D0%B0%D1%86%D1%83%D0%B1%D1%8B}
{Карацубы} 
для умножения больших чисел. \\
$AB * CD == (A + B * 2^m) * (C + D * 2^m)$ \\ 
$ \qquad == A * C + 2^{2*m} * B * D + 2^m * (B * C + A * D)$ \\
$ \qquad == A * C + 2^{2*m} * B * D + 2^m * ((A + B)(C + D) – A * C - B * D) $
\newpage

%------------------------------------------------------------------------------
\begin{center} Острова \end{center}
Задан двумерный массив из {0,1}. Островом называется связная группа единиц,
т.е. такие что от любой из них можно дойти до любой другой, перемещаюсь за шаг
на одну клетку вверх, вниз, вправо, влево или по диагонали и не попадая на 
клетки с '0'. Посчитать количество островов.
\newpage

%------------------------------------------------------------------------------
\begin{center} Операции над множествами через сортировку \end{center}
Написать следующие функции над массивами. Все они должны исполняться за
$O(n * log(n))$, где n - количество элементов в большем массиве.
В результирующем массиве не должно быть дубликатов.
\begin{itemize}
    \item union - пересечение двух множеств. Все элементы, которые есть 
          хотя-бы в одном из множеств.
    \item difference - все элементы, которые есть в одном из множеств, 
          но отсутствуют во втором.
\end{itemize}
\newpage

%------------------------------------------------------------------------------
\begin{center} FP \end{center}
Написать функции:
\begin{itemize}
    \item my\_map, принимает функцию и список, 
            возвращяет список полученный в итоге применения переданной функции 
            к каждому элементу из списка-параметра. 
            \lstinline!map(func, lst) == [func(lst[0]), func(lst[1]), ..., func(lst[N])]!
    \item my\_filter(func, lst1) -> lst2. lst2 содержит только те элементы из lst1,
          для которых func возвращает True
    \item my\_reduce(my\_fold) 
\href{http://ru.wikipedia.org/wiki/%D0%A1%D0%B2%D1%91%D1%80%D1%82%D0%BA%D0%B0_%D1%81%D0%BF%D0%B8%D1%81%D0%BA%D0%B0}{описание reduce}.
    \item рекурсивные варианты всех этих функций
    \item Функцию bind, которая принимает функцию func и список параметров params1
          и возвращает функцию, при вызове которой со списком параметров params2 вызывается
          func c объединенным списком параметров params1 + params2.
          То-же, но с поддержекой именованных аргументов.
          \lstinline!bind(func, 1, 2, "3")(2, 4) == func(1, 2, "3", 2, 4)!
    \item my\_map\_gen, my\_filter\_gen, my\_reduce\_gen, которые принимают генераторы и возвращают генераторы
\end{itemize}
\newpage

%------------------------------------------------------------------------------
\begin{center} super \end{center}
Написать my\_super, аналогичный по поведению встроенному 
\newpage

%-------------------------------------------------------------------------------
\begin{center} Задание - func\_info \end{center}
    Написать функцию func\_info, которая принимает функцию и печатает ее
    \begin{itemize}
        \item Имя
        \item Количество параметров
        \item Документацию
        \item Значения параметров по умолчанию
        \item Поля искать через ipython/google/\href{http://docs.python.org/reference/datamodel.html}{python doc}
    \end{itemize}
\newpage

%-------------------------------------------------------------------------------
\begin{center}Задание - композиция функций\end{center}
    Написать функцию haskell\_dot, которая принимает неограниченное количество функций
    и возвращает новую функцию, поторая при вызове последовательно применяет все 
    сохраненные функции к параметру. \\

    haskell\_dot(f1, f2, f3, ....) -> fC \\
    fC(x) = f1(f2(f3(...(x))))
\newpage

%------------------------------------------------------------------------------
\begin{center} Сериализация \end{center}
Написать функции, умеющуе сериализовать и десериализовать следующие типы данных:
list, int, str, dict и все их комбинации. Например такое значение
\lstinline!{'a':1, 'b':[1,2,3,['3']], 4:7}!. Длинные целые поддерживать не надо.
Сериализаций называется превращение значения в строку, представление которой не 
зависит от аппаратных особенностей компьютера. serialize должна возвращать строку,
вызов deserialize от которой вернет значение, равное значению, переданному в 
serialize. Нельзя использовать eval/pickle/marshal и прочие готовые решения.
Строки внутри передаваемого значения могут содержать любые символы (например
'\\x00', '\{', '\}', '[', ']', '(', ')', etc). Не стоит для преобразования 
полагаться на встроенное преобразование объектов в строку с помошью функций 
str/repr. 
Необходимые модули: struct. 
\newpage

%------------------------------------------------------------------------------
\begin{center} RPC \end{center}
Используя функцию из задачи "Сериализация" или pickle.dumps и сокеты 
реализовать сервер и клиент для удаленного вызова функций. Удаленный вызов
означает, что на одном компьютере(клиенте) вызывается специальная процедура-прокси
которая передает параметры по сети на сервер. На сервере необходимая процедура 
вызывается с этими параметрами. Результат передаетмя назад на клиент и 
процедура-прокси возвращает его. Таким образом код, испольщующий прокси не замечает
факта общения по сети.
\newpage

%------------------------------------------------------------------------------
\begin{center} Алгоритм Кнута-Морриса-Пратта \end{center}
\begin{itemize}
    \item 
\end{itemize}
\newpage

%-----------------------------------------------------------------------------
\begin{center} ИИ для шахмат \end{center}
\begin{itemize}
    \item Без взятия на проходе и рокировки
    \item Классы для фигур и доски
    \item функция оценки позиции
    \item перебор
    \item генетический алгоритм для подгона перебора
\end{itemize}
\newpage

%-----------------------------------------------------------------------------
\begin{center} Морской бой \end{center}

\newpage

%-----------------------------------------------------------------------------
\begin{center} ORM \end{center}
Задача \href{}{ORM} - преобразовывать python выражения в соответствующие 
запросы sql.
\begin{lstlisting}
t1 = orm.Table("users")
t2 = orm.Table("addresses")

expr = (t1.name == 'foo').and(t2.uid == t1.id)

print str(expr)

print str(orm.select(t2.address).where(expr))

\end{lstlisting}
\newpage

%-----------------------------------------------------------------------------
\begin{center} Выход из лабиринта \end{center}

\newpage

%-----------------------------------------------------------------------------
\begin{center} Тетрис \end{center}
ООП, сделать GUI - заготовку.
\newpage

%------------------------------------------------------------------------------
\end{document}
%------------------------------------------------------------------------------
% http://acm.mipt.ru/judge/problems.pl?psorto=compl~d&CGISESSID=660ae15a1fa989f66471c7b094375452
% http://codegolf.stackexchange.com/
% http://informatics.mccme.ru/moodle/ - много задач, но в основном слабые
