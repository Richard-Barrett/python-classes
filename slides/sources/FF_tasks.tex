% python classes slides - tasks
% (c) 2012 Kostiantyn Danylov aka koder 
% koder.mail@gmail.com
% distributed under CC-BY licence
% http://creativecommons.org/licenses/by/3.0/deed.en

\documentclass{article}
\input{files/lectures_env}
\input{files/python_cmds}
\begin{document}
\LARGE

%-------------------------------------------------------------------------------
\begin{center} Инсталляция питона \end{center}
\begin{itemize}
    \item Установить python
    %\item Создать виртуальное окружение для python, 
    %        вся дальнейшая работа будет идти из него
    \item Установаить pip/easy\_install
    \item Установить ipython (со всеми зависимостями)
    \item Проверить работу ipython qtconsole, ipython notebook
    %\item аккаунт на pikacode + mercurial + TortoiseHG
    %\item или аккаунт на github + git (привет, windows!)
    \item sublime-text-2 / notepad++ / vim / emacs /eclipse + pydev
    %\item Найти и прочитать pep8
    %\item \lstinline!import this! - the Zen of Python
    \item pylint
    \item winpdb
    \item В ipython справка по объекту - obj?<enter>
    \item
    \item \href{http://koder-ua.blogspot.com/2012/09/blog-post.html}{Более подробное описание}
\end{itemize}
\newpage

%-------------------------------------------------------------------------------
\begin{center} Строки \end{center}
\begin{itemize}
    \item Прочитать описание строковых операций
    \item Прочитать описание format
    \item \href{http://www.youtube.com/watch?feature=player_embedded&v=sgHbC6udIqc}{Pragmatic Unicode, or, How do I stop the pain?}
    \item \href{http://www.youtube.com/watch?v=kWyoYtvJpe4}{Google Python Class Day 2 Part 1: regular exression}
\end{itemize}
\newpage

%-------------------------------------------------------------------------------
\begin{center} Разложить число на простые делители \end{center}
Написать функцию factorize, которая возвращает все простые делители
у переданного числа.
\newpage

%------------------------------------------------------------------------------
\begin{center} строковые функции \end{center}
Написать строковые функции xfind, xreplace, xsplit, xjoin используя
срезы строк (без применения других методов строк).
\begin{itemize}
    \item \lstinline!xfind(s1, s2) == s1.find(s2)!
    \item \lstinline!xreplace(s1, s2, s3) == s1.replace(s2, s3)!
    \item \lstinline!xsplit(s1, s2) == s1.split(s2)!
    \item \lstinline!xjoin(s, array) == s.join(array)!
\end{itemize}
\newpage

%------------------------------------------------------------------------------
\begin{center} Преобразование в польскую нотацию \end{center}
\newpage

%------------------------------------------------------------------------------
\begin{center} Функтор \end{center}
1) Написать объект, который запоминает арифметические операции, проделанные над ним 
и может их повторить.
2) Написать объект, который трансформирует операции сравнения над собой в WHERE для SQL.

\begin{lstlisting}
    x = Var()
    f = 3 * x + x ** 2
    f(1) == 4

    y = SQL("table.field")
    str(y > 12 && y != 17)  == "table.field > 12 AND table.field != 17"
\end{lstlisting}
\newpage

%-------------------------------------------------------------------------------
\begin{center} Декодирование АОН \end{center}
\begin{itemize}
    \item Нужно преобразовать строку по следующим правилам:
    \item Если символ идет 2 и больше раз подрят - записать его в результат 1 раз
    \item Если символ повторяется 1 раз - отбросить
    \item Если \# повторяется два и более раз - последний символ, записанный в результат записать еще раз
\end{itemize}
\begin{lstlisting}
    decode("") == ""
    decode("1") == ""
    decode("11") == "1"
    decode("11111") == "1"
    decode("11#") == "1"
    decode("11##") == "11"
    decode("11122234###55") == "1225"
\end{lstlisting}
\newpage

%------------------------------------------------------------------------------
\begin{center} Разбор логов \end{center}
Разобрать файл логов на записи и записи на отдельные компоненты.
На выходе должен быть массив словарей \{field\_name $\rightarrow$ field\_value\}
\begin{Large}
\begin{lstlisting}
Nov  6 03:23:32 some-laptop anacron[9343]: Job 'cron.daily' terminated
Nov  6 03:23:32 some-laptop anacron[9343]: Normal exit (1 job run)
Nov  6 04:17:01 some-laptop CRON[13180]: (root) CMD (   
        cd / && run-parts --report /etc/cron.hourly)
Nov  6 05:17:01 some-laptop CRON[13573]: (root) CMD (   
        cd / && run-parts --report /etc/cron.hourly)
Nov  6 06:00:37 some-laptop NetworkManager[1049]: <info> 
        sleep requested (sleeping: no  enabled: yes)
Nov  6 06:00:37 some-laptop NetworkManager[1049]: 
        <info> sleeping or disabling...
\end{lstlisting}
\end{Large}
\newpage

%------------------------------------------------------------------------------
\begin{center}
\href{http://ru.wikipedia.org/wiki/%D0%93%D0%BD%D0%BE%D0%BC%D1%8C%D1%8F_%D1%81%D0%BE%D1%80%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B0}{Гномья сортировка}
\end{center}
В массиве сравниваются соседние элементы. 
Если они неупорядоченны - они меняются местами и делается шаг назад.
Если они упорядоченны, то шаг вперед. 
Если дошли до конца, то сортировка оконченна.
\newpage

%------------------------------------------------------------------------------
\begin{center} Двоичный поиск \end{center}
Найти елемент в упорядоченном массиве методом дихотомии.
\newpage

%------------------------------------------------------------------------------
\begin{center} Кодирование Шеннона — Фано \end{center}
\begin{itemize}
    \item Сообщение бъется на элементы
    \item Изначально коды для всех элементов пустые
    \item Элементы множества выписывают в порядке убывания вероятностей.
    \item Множество делится на две части, суммарные вероятности символов которых
            максимально близки друг другу.
    \item К коду первой половины элементов дописывается "0", второй "1"
    \item Алгоритм повторяется для обоих частей
\end{itemize}
\newpage

%------------------------------------------------------------------------------
\begin{center}Кодирование и декодирование файла по Хаффману.\end{center}
На диске есть файл с именем "input.txt". Его нужно прочитать, закодировать символы 
используя не адаптивный алгоритм 
\href{http://ru.wikipedia.org/wiki/%D0%9A%D0%BE%D0%B4_%D0%A5%D0%B0%D1%84%D1%84%D0%BC%D0%B0%D0%BD%D0%B0}{Хаффмана}  и записать результат в 
output.bin. В решении должно быть две функции 
hf\_encode(string) str->str, и hf\_decode(string) str->str. 
Первая кодирует, вторая декодирует. 
Входными элементами для алгоритма являются отдельные байты файла.
\newpage

%------------------------------------------------------------------------------
\begin{center} Интерпретатор minilisp \end{center}
Программа на mini-lisp имеет вид (oper param1 param2 para3 .... paramn),
здесь oper это имя функции - любой набор символов, кроме пробелов.
param2 - целое, строка в кавычках (без кавычек внутри) или другая программа на mini-lisp.
Допустимые oper - '+' (складывает все операнды), '-' (вычитает из первого все операнды), 
print (печатает все операнды через пробел). Сложение имеет такой же смысл, как и в питоне. 
Вычитание для строк не определено. Нужно написать функция eval\_minilisp, которая 
исполнить программу переданную параметром. 
По умолчанию из main вызывать eval\_minilisp("example.lst")

\begin{itemize}
    \item \lstinline!eval_minilisp('(+ 1 2 3)')! должна вернуть 6
    \item \lstinline!eval_minilisp('(print (+ "a" "bc"))')! => должны напечатать 'abc'
\end{itemize}
\newpage

%------------------------------------------------------------------------------
\begin{center} Интерпретатор minilisp с промежуточным деревом \end{center}
\begin{itemize}
    \item Сделать задание "Интерпретатор minilisp" но промежуточно необходимо преобразовать
        дерево в форму, удобную для промежуточной обработки. 
    \item Сделать систему разбора расширяемой снаружи новыми командами.
\end{itemize}
\newpage

%------------------------------------------------------------------------------
\begin{center} интерпретатор подмножества языка forth \end{center}
      Программа на Forth состоит из набора команд(слов),
      некоторые из которых имеют параметры. Для хранения данных используется стек -
      команды получают свои операнды с вершины стека и туда же сохраняют результаты.
      В  подмножестве 5 команд:
\begin{itemize}
    \item put значение - помещает значение в стек. Значение может
          быть числом или строкой. Строка заключается в кавычки, внутри
          строки кавычек быть не может.
    \item pop - убирает значение из стека
    \item add - убирает из стека 2 значения, складывает их и помещает результат в стек
    \item sub - убирает из стека 2 значения, вычитает их и помещает результат в стек
    \item print - вынимает из стека 1 значение и печатает его.
\end{itemize}


\begin{lstlisting}
    put 3
    put "asdaadasdas"
\end{lstlisting}

    Каждая команда начинается с новой строки. Строки, начинающиеся с '\#' - комментарии.
    Ваша программа должна содержать функцию eval\_forth(), принимающую строку на языке
    forth и исполняющую ее. По умолчанию из main вызывать eval\_forth("example.frt")
    Пример, если в example.rft будет:

\begin{lstlisting}
    put 1
    put 3
    add
    print
\end{lstlisting}

    То программа должна напечатать '4'. 

    Сложение имеет такой же смысл, как и в питоне. Вычитание для строк не определено
    Программа должна содержать функцию eval\_forth(), принимающую строку на языке forth и исполняющую ее. 
    По умолчанию из main вызывать eval\_forth("example.frt")
\newpage

%------------------------------------------------------------------------------
\begin{center} Умножение больших чисел \end{center}
Реализовать алгоритм 
\href{http://ru.wikipedia.org/wiki/%D0%A3%D0%BC%D0%BD%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D0%B5_%D0%9A%D0%B0%D1%80%D0%B0%D1%86%D1%83%D0%B1%D1%8B}
{Карацубы} 
для умножения больших чисел. \\
$AB * CD == (A + B * 2^m) * (C + D * 2^m)$ \\ 
$ \qquad == A * C + 2^{2*m} * B * D + 2^m * (B * C + A * D)$ \\
$ \qquad == A * C + 2^{2*m} * B * D + 2^m * ((A + B)(C + D) – A * C - B * D) $
\newpage

%------------------------------------------------------------------------------
\begin{center} Острова \end{center}
Задан двумерный массив из {0,1}. Островом называется связная группа единиц,
т.е. такие что от любой из них можно дойти до любой другой, перемещаюсь за шаг
на одну клетку вверх, вниз, вправо, влево или по диагонали и не попадая на 
клетки с '0'. Посчитать количество островов.
\newpage

%------------------------------------------------------------------------------
\begin{center} Операции над множествами через сортировку \end{center}
Написать следующие функции над массивами. Все они должны исполняться за
$O(n * log(n))$, где n - количество элементов в большем массиве.
В результирующем массиве не должно быть дубликатов.
\begin{itemize}
    \item union - пересечение двух множеств. Все элементы, которые есть 
          хотя-бы в одном из множеств.
    \item difference - все элементы, которые есть в одном из множеств, 
          но отсутствуют во втором.
\end{itemize}
\newpage

%------------------------------------------------------------------------------
\begin{center} Поиск удаленных и созданных файлов \end{center}
Написать функцию, которая получает два пути, проходит по 
указанным дирректориям и всем вложенным и находит какие файлы 
есть только в одной из них. Возвращает пару списков с именами файлов,
имеющимися только в одной из дирректорий.
\newpage

%------------------------------------------------------------------------------
\begin{center} FP \end{center}
Написать функции:
\begin{itemize}
    \item my\_map, принимает функцию и список, 
            возвращяет список полученный в итоге применения переданной функции 
            к каждому элементу из списка-параметра. 
            \lstinline!map(func, lst) == [func(lst[0]), func(lst[1]), ..., func(lst[N])]!
    \item my\_filter(func, lst1) -> lst2. lst2 содержит только те элементы из lst1,
          для которых func возвращает True
    \item my\_reduce(my\_fold) 
\href{http://ru.wikipedia.org/wiki/%D0%A1%D0%B2%D1%91%D1%80%D1%82%D0%BA%D0%B0_%D1%81%D0%BF%D0%B8%D1%81%D0%BA%D0%B0}{описание reduce}.
    \item рекурсивные варианты всех этих функций
    \item Функцию bind, которая принимает функцию func и список параметров params1
          и возвращает функцию, при вызове которой со списком параметров params2 вызывается
          func c объединенным списком параметров params1 + params2.
          То-же, но с поддержекой именованных аргументов.
          \lstinline!bind(func, 1, 2, "3")(2, 4) == func(1, 2, "3", 2, 4)!
    \item my\_map\_gen, my\_filter\_gen, my\_reduce\_gen, которые принимают генераторы и возвращают генераторы
\end{itemize}
\newpage

%------------------------------------------------------------------------------
\begin{center} super \end{center}
Написать my\_super, аналогичный по поведению встроенному 
\newpage

%------------------------------------------------------------------------------
\begin{center} Oбработка файла \end{center}
Написать конвеерные генераторы для обработки тектовых потоков.
\begin{itemize}
    \item iter\_lines(fd) получает имя файла итерирует по строкам. 
           Для чтения можно использовать только fd.read(1)
    \item strip\_spaces(iter) -> принимает итератор, получает из него 
          строки и возвращает строки без стартовых и финальных пробельных символов
    \item drop\_empty - получает итератор и возвращает только не пустые строки
    \item split\_items - получает итератор, считывает из него строки, 
          разбивает их по пробелам и для каждого элемента определяет является ли он
          строковым представлением целого или числа с плавающей запятой.
          Приводит опознанные елементы к int/float соответсвенно, остальные оставляет
          строками. Возращает итератор по этим элементам
    \item get\_ints - возращает из входного потока только целые
    \item my\_sum - считает сумму элементов целых во входном потоке
\end{itemize}

\begin{lstlisting}
    # fd == "1 2 3 3.45 abra_cadabra   \n\n12"
    list(iter_lines(fd)) == \
        ["1 2 3 3.45 abra_cadabra   ", "", "12"]
    list(strip_spaces(iter_lines(fd))) == \
        ["1 2 3 3.45 abra_cadabra", "", "12"]
    list(drop_empty(["1 2 3 3.45 abra_cadabra", "", "12"])) == \
        ["1 2 3 3.45 abra_cadabra", "12"]
    list(split_items(["1 2 3 3.45 abra_cadabra", "12"])) == \
        [1, 2, 3, 3.45, "abra_cadabra", 12]
    list(get_ints([1, 2, 3, 3.45, "abra_cadabra", 12])) == \
        [1, 2, 3, 12]
    my_sum([1, 2, 3, 12]) == 18

    my_sum(get_ints(drop_empty(strip_spaces(iter_lines(fd))))) == 18
\end{lstlisting}

\newpage

%------------------------------------------------------------------------------
\begin{center}Сайт на CherryPy\end{center}
\href{http://www.cherrypy.org/}{CherryPy} это библиотека для написания простых веб приложений.
Необходимо написать иерархию классов для сайта. 
\begin{itemize}
    \item Пустой класс Router
    \item Класс BaseSite с методом index, который возвращает "Hello"
    \item Класс PolliteSite, наследующий BaseSite, имеющий метод set\_name,
            принимающий имя в качестве параметра.
            В методе index он должен возвращать "Hello" + name. name по умолчанию пустое.
    \item Класс StructuredSite от PolliteSite, который добавляет два метода - header и footer.
          Заголовок и подложка, которые должны выводиться вверху и внизу каждой страници.
          По умолчанию он пишет в footer текущее время (модуль datetime). А в header - 
          "name {текущщее имя пользователя}".

\end{itemize}

CherryPy привращает HTTP запрос (та строка, которую вы вводите в адресной строке браузера)
вида http://domain/x/y/z?var1=val1\&var2=val2
в вызов RootObject.x.y.z(var1=val1, var2=val2) или в вызов \\
RootObject.x.y.z.index(var1=val1, var2=val2) в зависимости от того, что есть.

\begin{lstlisting}
    import cherrypy

    class Router(object):
        pass

    Router.base = BasicSite()
    Router.pollite1 = PolliteSite()
    Router.pollite2 = PolliteSite()

    cherrypy.quickstart(HelloWorld())
\end{lstlisting}

Запускаем эту программу, запускаем браузер и вводим в адресной строке '127.0.0.1:8080'.

\newpage

%-------------------------------------------------------------------------------
\begin{center} Задание - func\_info \end{center}
    Написать функцию func\_info, которая принимает функцию и печатает ее
    \begin{itemize}
        \item Имя
        \item Количество параметров
        \item Документацию
        \item Значения параметров по умолчанию
        \item Поля искать через ipython/google/\href{http://docs.python.org/reference/datamodel.html}{python doc}
    \end{itemize}
\newpage

%-------------------------------------------------------------------------------
\begin{center}Задание - композиция функций\end{center}
    Написать функцию haskell\_dot, которая принимает неограниченное количество функций
    и возвращает новую функцию, поторая при вызове последовательно применяет все 
    сохраненные функции к параметру. \\

    haskell\_dot(f1, f2, f3, ....) -> fC \\
    fC(x) = f1(f2(f3(...(x))))
\newpage

%------------------------------------------------------------------------------
\begin{center} ООП 1 \end{center}
\begin{itemize}
    \item Сделать класс рациональное число (BasicRationalNumber),
        имеющий два поля - числитель и знаменатель. Значения этих полей 
        должны передаваться в конструктор класса BasicRationalNumber.
    \item Сделать класс CalcRationalNumber, который имеет методы add,
        sub, mul and div. Которые, соответсвенно, вычисляю сумму, разность,
        произведение и отношение текущего RationalNumber и переданного в качестве 
        параметра.
    \item Сделать класс SimplRationalNumber, который автоматически делит
        числитель и знаменатель на наибольший общий делитель после каждой операции
    \item Добавить в класс BasicRationalNumber метод \_\_str\_\_ из которого возвращать
        строковое представление объекта
\end{itemize}

\begin{lstlisting}
    def mk_str(rn):
        return "{}/{}".format(rn.numer, rn.denom)

    rn = BasicRationalNumber(2, 3)
    print mk_str(rn) # 2/3

    x1 = CalcRationalNumber(1, 2)
    x2 = CalcRationalNumber(1, 3)
    x3 = x1.sub(x2)
    print mk_str(x3) # 1/6

    x3 = x3.add(x3)
    print mk_str(x3) # 2/6

    x4 = SimplRationalNumber(1, 6)
    x4.add(x4)
    print mk_str(x4) # 1/3
\end{lstlisting}
\newpage

%------------------------------------------------------------------------------
\begin{center} web crawler \end{center}
Написать программу для загрузки веб сайтов. На вход передается url и глубина.
Программа должна загрузить указанную страницу и все страници с того же домена,
на которые она ссылается прямо или не более чем через X-1 страниц, где X - 
указанная глубина.
\newpage

%------------------------------------------------------------------------------
\begin{center} Сериализация \end{center}
Написать функции, умеющуе сериализовать и десериализовать следующие типы данных:
list, int, str, dict и все их комбинации. Например такое значение
\lstinline!{'a':1, 'b':[1,2,3,['3']], 4:7}!. Длинные целые поддерживать не надо.
Сериализаций называется превращение значения в строку, представление которой не 
зависит от аппаратных особенностей компьютера. serialize должна возвращать строку,
вызов deserialize от которой вернет значение, равное значению, переданному в 
serialize. Нельзя использовать eval/pickle/marshal и прочие готовые решения.
Строки внутри передаваемого значения могут содержать любые символы (например
'\\x00', '\{', '\}', '[', ']', '(', ')', etc). Не стоит для преобразования 
полагаться на встроенное преобразование объектов в строку с помошью функций 
str/repr. 
Необходимые модули: struct. 
\newpage

%------------------------------------------------------------------------------
\begin{center} RPC \end{center}
Используя функцию из задачи "Сериализация" или pickle.dumps и сокеты 
реализовать сервер и клиент для удаленного вызова функций. Удаленный вызов
означает, что на одном компьютере(клиенте) вызывается специальная процедура-прокси
которая передает параметры по сети на сервер. На сервере необходимая процедура 
вызывается с этими параметрами. Результат передаетмя назад на клиент и 
процедура-прокси возвращает его. Таким образом код, испольщующий прокси не замечает
факта общения по сети.
\newpage

%------------------------------------------------------------------------------
\begin{center} Обход дерева \end{center}
Найти 10 самых больших файлой в дереве, начинающемся с указанной папки.
Необходимые функции: os.stat, os.walk.
\newpage

%------------------------------------------------------------------------------
\begin{center} Создание дерева папок \end{center}
Написать функцию, которая получает словарь вида 
\{str: str or None\} и строку(root) и создает на диске дерево файлов следующиего вида - 
для каждого элемента в словаре, у которого значение не None - создается файл 
с путем os.path.join(root, "ключ елемента") и в него записывается значение элемента.
Если значение None - то по аналогичному пути создается директория.
пример:

вызов \lstinline!create_tree("/tmp/test_dir", \{'a':None, 'b/c':'xxxx', 'm/t/y/u':None\})!
создаст пустые папки \lstinline!'/tmp/test_dir/a'! и \lstinline!'/tmp/test_dir/m/t/y/u'!
и файл "/tmp/test\_dir/b/c", содержащий 'xxxx'.

\newpage

%------------------------------------------------------------------------------
\begin{center} Сравнение папок \end{center}
Сравнить два дерева папок в файловой системе. Фукция получает два пути к 
папкам в файловой системе и находит все файлы, которые присутвуют только в 
одном из деревьев, но отсутвуют в другом. Файл считается отсутвующим, если 
в аналогичной папке в другом дереве нет файла с таким-же именем. Наличие файла 
с таким же именем в другой папке второго дерева не учитывать. Файлы сравниваются
только по имени, содержимое и атрибуты не учитываются. Аналогичной называется 
папка имеющая такой же путь от своего корня. Например - папки
/x/y/z и /t/r/z считаются аналогичными, если корни /x/y и /t/r соответственно.
Функция итерирует по всем таким файлам, для каждого из них выбрасывая наверх
пару (bool \{True если файл только в первой папке, False - если только во второй\},
 путь от того корня, под которым файл найден)

Для юнит-тестирования используйте функцию из задания "Создание дерева папок".

Необходимые функции: os.path.join, os.walk, os.listdir, shutil.rmtree.
\newpage

%------------------------------------------------------------------------------
\begin{center} Алгоритм Кнута-Морриса-Пратта \end{center}
\begin{itemize}
    \item 
\end{itemize}
\newpage

%-----------------------------------------------------------------------------
\begin{center} Разбор HTTP запроса \end{center}
Сделать функцию, которая получает на вход строку HTTP запроса
и возвращает удобный для обработки объект
\begin{lstlisting}

request = """
POST /x/y/z HTTP/1.0
Host: some.host.org
content-type:application/x-www-form-urlencoded;charset=utf-8
content-length:207

Action=GetStatus
&JobId=JOBID
&AWSAccessKeyId=AKIAIOSFODNN7EXAMPLE
&SignatureMethod=HmacSHA256
&SignatureVersion=2
&Version=2010-06-03
&Signature=lBP67vCvGlDMBQ1dofZxg8E8SUEXAMPLE
&Timestamp=2011-06-20T22%3A30%3A59.556Z
"""

\end{lstlisting}
\newpage

%-----------------------------------------------------------------------------
\begin{center} ИИ для шахмат \end{center}
\begin{itemize}
    \item Без взятия на проходе и рокировки
    \item Классы для фигур и доски
    \item функция оценки позиции
    \item перебор
    \item генетический алгоритм для подгона перебора
\end{itemize}
\newpage

%-----------------------------------------------------------------------------
\begin{center} Морской бой \end{center}

\newpage

%-----------------------------------------------------------------------------
\begin{center} ORM \end{center}

\newpage

%-----------------------------------------------------------------------------
\begin{center} Выход из лабиринта \end{center}

\newpage

%-----------------------------------------------------------------------------
\begin{center} Тетрис \end{center}
ООП, сделать GUI - заготовку
\newpage

%------------------------------------------------------------------------------
\begin{center} subprocess \end{center}
Используя subprocess запустить в фоне tcpdump и выводить на количество траффика
по отдельным протоколам.
\newpage

%------------------------------------------------------------------------------
\end{document}
%------------------------------------------------------------------------------
% http://acm.mipt.ru/judge/problems.pl?psorto=compl~d&CGISESSID=660ae15a1fa989f66471c7b094375452
% http://codegolf.stackexchange.com/
% http://informatics.mccme.ru/moodle/ - много задач, но в основном слабые
