1) Разложить число на простые делители

2) Нужно преобразовать строку по следующим правилам:
- Если символ идет 2 и больше раз подрят - записать его в результат 1 раз
- Если символ повторяется 1 раз - отбросить
- Если # повторяется два и более раз - последний символ, записанный в результт записать еще раз

"" => ""
"1" => ""
"11" => "1"
"11111" => "1"
"11#" => "1"
"11##" => "11"
"11122234###55" => "1225"

3) Гномья сортировка
Сравниваются соседние элементы. Если они неупорядоченны - они меняются местами и делается шаг назад.
Если они упорядоченны, то шаг вперед. Если дошли до конца, то сортировка оконченна.

4) Двоичный поиск
Найти елемент в упорядоченном массиве.

5) Кодирование по Шеннона — Фано

    * Изначально коды для всех элементов пустые
    * Элементы множества выписывают в порядке убывания вероятностей.
    * Делятся на две части, суммарные вероятности символов которых
        максимально близки друг другу.
    * К коду первыой половины элементов дописывается "0", второй "1"
    * Алгоритм повторяется для обоих частей


6) Интерпретатор mini-lisp

    Программа на mini-lisp имеет вид (oper param1 param2 para3 .... paramn),
здесь oper - имя функции - любой набор символов, кроме пробелов;
param2 - целое, строка в кавычках (без кавычек внутри) или другая программа на mini-lisp.
Допустимые oper - + (складывает все операнды), - (вычитает из первого все операнды), 
print (печатает все операнды через пробел). Нужно исполнить программу, переданную на вход.

Например

(+ 1 2 3) => 6
(print (+ "a" "bc")) => печатает abc

7) Написать интерпретатор подмножества языка forth.

Программа на Forth состоит из набора команд(слов), некоторые
из которых имеют параметры. Для хранения данных используется
стек - команды получают свои операнды с вершины стека и туда
же сохраняют результаты. В подмножестве 5 команд:

put значение - ложит значение на вершину стека. Значение может
быть числом или строкой. Строка заключается в кавычки, внутри
строки кавычек быть не может
pop - убирает значение с вершины стека
add - изымает из стека 2 значения, складывает их, кладет результат в стек
sub - изымает из стека 2 значения, вычитает их, кладет результат
в стек
print - вынимает из стека 1 значение, печатает его.

Каждая команда начинается с новой строки. Строки, начинающиеся с '#' - комментарии. Ваша программа должна содержать функцию eval_forth(), принимающую строку на языке forth и исполняющую ее. По умолчанию из main вызывать eval_forth("example.frt")
Пример, если в example.rft будет:

put 1
put 3
25
add
print

То программа должна напечатать '4'. Сложение имеет такой же
смысл, как и в питоне. Вычитание для строк не определено


8) Написать строковые функции xfind, xreplace, xsplit, xjoin используя
срезы строк (без применения других методов строк).
xfind(s1, s2) == s1.find(s2)
xreplace(s1, s2, s3) == s1.replace(s2, s3)
xsplit(s1, s2) == s1.split(s2)
xjoin(s, array) == s.join(array)

9) кодирование и декодирование файла по Хаффману. 
На диске есть файл с именем "input.txt". Его нужно прочитать, зако-дировать символы 
использую алгоритм Хаффмана и записать результат в output.bin. В решении должно быть две функции 
hf_encode(string) str->str, и hf_decode(string) str->str. Первая кодирует, вторая деко-дирует. 
Входными элементами для алгоритма являются отдельные байты файла.

2) http://acm.mipt.ru/judge/problems.pl?psorto=compl~d&CGISESSID=660ae15a1fa989f66471c7b094375452
3) http://codegolf.stackexchange.com/
