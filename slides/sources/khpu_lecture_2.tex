% python classes slides - refactored lection for khpu
% (c) 2012 Kostiantyn Danylov aka koder 
% koder.mail@gmail.com
% distributed under CC-BY licence
% http://creativecommons.org/licenses/by/3.0/deed.en

\documentclass{article}
\input{files/lectures_env}
\input{files/python_cmds}
\begin{document}
\LARGE

%-------------------------------------------------------------------------------
\center{Блоки кода}
\begin{itemize}
    \item Блоки ограничивают участок кода, принадлежащий управляющей конструкции
    \item Начинаются с “:”, которым оканчивается конструкция 
    \item Все строки блока имеют уровень отступа равным начальной строке блока
    \item Отступы делаются с помошью табуляции или пробелов
    \item Блоки могут содержать другие блоки (с более глубокими отступами)
\end{itemize}
\vspace{15pt}
\begin{lstlisting}
    Some_contruction:
        y = 2
        z = x + y
    #end_of_block
\end{lstlisting}
\newpage

%-------------------------------------------------------------------------------
\center{Блоки кода}
\begin{itemize}
    \item Блоки это не области видимости переменных. Переменные видны и после выхода из блока
    \item \lstinline$pass$ – пустой блок
\end{itemize}
\newpage

%-------------------------------------------------------------------------------
\center{if - Условное выполнение участков кода}
\vspace{15pt}
\begin{lstlisting}
    if  condition1 :
        pass # excuted if condition1 is true
    elif condition2 :
        pass # excuted if condition1 is false and condition2 is true
    #... 
    else:
        pass # executed if all conditions is false 
\end{lstlisting}
\newpage

%-------------------------------------------------------------------------------
\center{if}
\vspace{15pt}
\begin{lstlisting}
    x = 12
    sign = 0
    if x > 0:
        print x, "positive"
        sign = 1
    elif x < 0:
        print x, "negative"
        sign = -1
    else:
        print x, "== 0"
        sign = 0
\end{lstlisting}
\newpage

%-------------------------------------------------------------------------------
\center{inline if}
\vspace{15pt}
\begin{lstlisting}
    res = x if x >= 0 else -x
    # res = (x >= 0 ? x : -x)
\end{lstlisting}
\newpage

%-------------------------------------------------------------------------------
\center{while}
\vspace{15pt}
\begin{lstlisting}
    while condition:
        pass # executed while condition is true
    else:
        pass # if no error or break in body

    x = 1
    while x < 100:
        print x, "less than 100"
        x *= 2
\end{lstlisting}
\newpage

%-------------------------------------------------------------------------------
\center{for - цикл по множеству}
\vspace{15pt}
\begin{lstlisting}
    for x in iterable:
        func(x) # for each element in iterable
    else:
        pass # if no error or break in body

    sum = 0
    for x in range(100):
        sum += x
    print x  # 99 * 100 / 2

    for i in range(n): # xrange(n)
        pass

\end{lstlisting}
\newpage

%-------------------------------------------------------------------------------
\center{for undercover}
\vspace{15pt}
\begin{lstlisting}
    for x in container:
        f(x)

    # some times equal to

    _tmp = 0
    while _tmp < len(container):
        x = container[_tmp]
        f(x)
        _tmp += 1
\end{lstlisting}
\newpage

%-------------------------------------------------------------------------------
\center{break \& сontinue как всегда}
\begin{itemize}
    \item \lstinline!break!  выходит из цикла
    \item \lstinline!continue! переходит к следующей итерации
\end{itemize}
\newpage

%-------------------------------------------------------------------------------
\center{Задача}

\begin{itemize}
    \item нужно декодировать телефонный номера для АОН.
    \item По запросу АОНа АТС посылает телефонный номер, используя следующие правила:
    \item - Если цифра повторяется менее 2 раз, то она должна быть отброшена
    \item - Каждая значащая цифра повторяется минимум 2 раза
    \item - Если в номере идут несколько цифр подряд, то для обозначения «такая же цифра как
         предыдущая» используется идущий 2  или более подряд раз знак \#
    \item Входящая строка 4434\#\#\#552222311333661 => 4452136
\end{itemize}
\newpage

%-------------------------------------------------------------------------------
\center{list – Список (Массив)}
\begin{itemize}
    \item Упорядоченное множество элементов, доступ по номеру
    \item \lstinline!var = [1, 2, 3]!
    \item Индексация \lstinline!arr[x]!
    \item Срезы 
            \lstinline!arr[frm:to:step]! \\
            \lstinline![arr[frm], arr[frm + step], ....., ]!
    \item Отрицательный индекс - отсчет от конца. x[-1]
    \item Отсутвие индекса - frm -> 0, to -> -1, step -> 1
    \item arr[::-1] - инверсия элементов
    \item arr[:] - копия
\end{itemize}
\newpage

%-------------------------------------------------------------------------------
\center{list – Список (Массив)}
{
\Huge
\begin{flushleft}
$x = [0_{-6}^{0}, 1_{-5}^{1}, 2_{-4}^{2}, 3_{-3}^{3}, 4_{-2}^{4}, 5_{-1}^{5}]$ \\
\vspace{0.5cm}
x[2] == 2 \hspace{2cm}[\textcolor{red}{0, 1,} 2, \textcolor{red}{3, 4, 5}] \\
\vspace{0.5cm}
x[-2] == 4 \hspace{2cm}[\textcolor{red}{0, 1, 2, 3,} 4, \textcolor{red}{5}] \\
\vspace{0.5cm}
x[2:] == [2, 3, 4, 5] \hspace{2cm}[\textcolor{red}{0, 1, }2, 3, 4, 5] \\
\vspace{0.5cm}
x[-2:] == [4, 5] \hspace{2cm}[\textcolor{red}{0, 1, 2, 3,} 4, 5] \\
\vspace{0.5cm}
x[1:-1] == [1, 2, 3, 4] \hspace{2cm}[\textcolor{red}{0,} 1, 2, 3, 4, \textcolor{red}{5}] \\
\vspace{0.5cm}
x[1:-1:2] == [1, 3] \hspace{2cm}[\textcolor{red}{0,} 1, \textcolor{orange}{2,} 3, \textcolor{orange}{4,} \textcolor{red}{5}] \\
\vspace{0.5cm}
x[::-1] == [5, 4, 3, 2, 1, 0] \\
\end{flushleft}
}
\newpage

%-------------------------------------------------------------------------------
\center{list – Операции нам элементам и срезам}
\vspace{15pt}
\begin{lstlisting}
    x = [3, 4, 5, 6]
    x[::2] = [2, 2]  # x == [2, 4, 2, 6]
    x[::2] = 2 # error
    del x[1] # x == [3, 5, 6]
    x = [1, None, True, ["123", 2.4]]
    [1, 2, 3] + ["a", "b"] # [1, 2, 3, "a", "b"]
\end{lstlisting}
\newpage

%-------------------------------------------------------------------------------
\center{Методы списка}
{\Large
\vspace{15pt}
\begin{lstlisting}
    # arr.append(val)
    [1, 2].append(3) == [1, 2, 3]

    # arr.extend(arr2)
    [1, 2].extend([2, 3]) == [1, 2, 2, 3]

    # arr.pop()
    x = [1, 2]
    x.pop() == 2
    print x # [1]pfdnhf 

    # arr.insert(pos, val)
    [1, 2].insert(0, "abc") == ["abc", 1, 2]

    [1, 2].index(2) == 1
    [1, 2].reverse() == [2, 1]
    [1, 2, 4, 1, 2, 4, 1, 1].count(1) == 4
    x = [1, 3, 2]
    x.remove(1) # x == [3, 2]
    x.sort() # x == [2, 3]
\end{lstlisting}
}
\newpage

%-------------------------------------------------------------------------------
\center{Range}
\vspace{15pt}
\begin{lstlisting}
    range(x) == (0, ..., x – 1)
    range(x, y, z) == range(x)[:y:z]
\end{lstlisting}
\newpage

%-------------------------------------------------------------------------------
\center{assert}
\begin{itemize}
    \item \lstinline!assert expr[, msg]!
    \item \lstinline!assert x == 1, "X should be equal to 0"!
\end{itemize}
\newpage

%-------------------------------------------------------------------------------
\center{Функции - минимум}
\begin{lstlisting}
    def func_name1(param1, param2):
        "documentation"
        # block
        x = param1 + param2
        return x

    def func_name2(param1, param2):
        "documentation"
        # block
        x = param1 + param2
        if x > 0:
            return x
        else:
            return 0
\end{lstlisting}
\newpage

%-------------------------------------------------------------------------------
\center{Program template}
\begin{lstlisting}
    #!/usr/bin/end python
    # -*- coding:utf8 -*-
    ......

    def main():
        res = 0
        .....
        return res

    if __name__ == "__main__":
        exit(main())
\end{lstlisting}
\newpage


%-------------------------------------------------------------------------------
\center{Гномья сортировка}
\begin{itemize}
    Гномья сортировка основана на технике, используемой обычным голландским садовым гномом (нидерл. tuinkabouter). Это метод, которым садовый гном сортирует линию цветочных горшков. По существу он смотрит на следующий и предыдущий садовые горшки: если они в правильном порядке, он шагает на один горшок вперёд, иначе он меняет их местами и шагает на один горшок назад. Граничные условия: если нет предыдущего горшка, он шагает вперёд; если нет следующего горшка, он закончил.
\end{itemize}
\newpage 

%-------------------------------------------------------------------------------
\center{tuple – кортеж}
\begin{itemize}
    \item Константный список ( но можно изменять элементы, если они не константные)
\end{itemize}
\vspace{15pt}
\begin{lstlisting}
    tpl = (1, 2)
    tpl = 1,2
    tpl[1] = 3 # error
    tpl = (1, [2, 3, 4])
    tpl[1].append(1) => (1, [2, 3, 4, 1])
    (1) == 1
    (1,) == (1,)
    user, passwd = ("user", "qwerty") 
\end{lstlisting}
\newpage

%-------------------------------------------------------------------------------
\center{dict - словарь}
\begin{itemize}
    \item Набор пар (ключ, значение), с быстрым поиском по ключу
    \lstinline$x = {1:2, "3":4}$
    \item Только константные ключи (tuple - ok)
    \item Элементы неупорядоченны
    \item Нет срезов
\end{itemize}
\vspace{15pt}
\begin{lstlisting}
    x[1] == 2
    x[2] #error
    1 in x == True
    x[17] = True
    # x = {1:2, "3":4, 17:True}
\end{lstlisting}
\newpage

%-------------------------------------------------------------------------------
\center{dict – Словарь}
\vspace{15pt}
\begin{lstlisting}
    x = {1:2, "3":"4"}
    dict(a=1, b=2) == {"a":1, "b":2}
    x.items() == [(1, 2), ("3", "4")]
    x.values() == [2, "4"]
    x.keys() == [1, "3"]
    x.copy() == {1:2, "3":"4"}
    x.setdefault(key, val) == val # if key not in x else x[key]
    x.get(5, None) == None # if 5 not in x else x[5]
    x.clear() # {}
    x.update(y)
    dict.fromkeys(keys, val) # {key[0]:val, key[1]:val, ..} default val is None
\end{lstlisting}
\newpage

%-------------------------------------------------------------------------------
\center{Алгоритм Шеннона — Фано}
\begin{itemize}
    \item Элементы выписывают в порядке убывания вероятностей.
    \item Делятся на две части, суммарные вероятности символов которых максимально близки друг другу.
    \item В префиксном коде для первой части алфавита присваивается двоичная цифра «0», второй части — «1».
    \item Полученные части рекурсивно делятся и их частям назначаются соответствующие двоичные цифры в префиксном коде.
\end{itemize}
\newpage

%-------------------------------------------------------------------------------
\center{ДЗ}
\begin{itemize}
    \item Написать строковые функции xfind, xreplace, xsplit, xjoin используя срезы строк 
            (без применения других методов строк). \\
          xfind(s1, s2) == s1.find(s2) \\
          xreplace(s1, s2, s3) == s1.replace(s2, s3) \\
          xsplit(s1, s2) == s1.split(s2) \\
          xjoin(s, array) == s.join(array)

    \item Написать кодирование и декодирование файла по Хаффману. 
          На диске есть файл с именем "input.txt". 
          Его нужно прочитать, закодировать символы использую алгоритм Хаффмана
          и записать результат в output.bin. В решении должно быть две функции
          hf\_encode(string) str->str, и hf\_decode(string) str->str.
          Первая кодирует, вторая декодирует. Входными элементами для алгоритма
          являются отдельные байты файла.

    \item Написать интерпретатор подмножества языка forth. 

            Программа на Forth состоит из набора команд(слов),
            некоторые из которых имеют параметры. Для хранения данных используется стек -
            команды получают свои операнды с вершины стека и туда же сохраняют результаты.
            В  подмножестве 5 команд: \\

            put значение - ложит значение на вершину стека.
            Значение может быть числом или строкой. 
            Строка заключается в кавычки, внутри строки кавычек быть не может \\

            pop - убирает значение с вершины стека \\
            add - изымает из стека 2 значения, складывает их, кладет результат в стек\\
            sub - изымает из стека 2 значения, вычитает их, кладет результат в стек \\
            print - вынимает из стека 1 значение, печатает его. \\


\begin{verbatim}
    put 3
    put "asdaadasdas"
\end{verbatim}

            Каждая команда начинается с новой строки. Строки, начинающиеся с '\#' - комментарии.
            Ваша программа должна содержать функцию eval\_forth(), принимающую строку на языке
            forth и исполняющую ее. По умолчанию из main вызывать eval\_forth("example.frt")
            Пример, если в example.rft будет:

\begin{verbatim}
    put 1
    put 3
    add
    print
\end{verbatim}

            То программа должна напечатать '4'. Сложение имеет такой же смысл, как и в питоне. 
            Вычитание для строк не определено, все входные данные проверять с помощью assert.

\end{itemize}
\newpage

\end{document}
