% python classes slides - classes
% (c) 2012 Kostiantyn Danylov aka koder 
% koder.mail@gmail.com
% distributed under CC-BY licence
% http://creativecommons.org/licenses/by/3.0/deed.en

\documentclass{article}
\input{files/lectures_env}
\input{files/python_cmds}
\usepackage[normalem]{ulem}
\begin{document}
\LARGE

% TODO isinstance, issubclass
%-------------------------------------------------------------------------------
\center{Классы}
\begin{itemize}
	\item Класс это объединение данных и функций, работающих над ними
	\item Данные должны быть взаимосвязанны, а функции формировать API, 
			достаточное для полноценной работы над данными \sout{без прямого 
			доступа к ним}
	\item Язык обеспечивает автоматизацию многих задач по поддержке ООП
\end{itemize}
\newpage

%-------------------------------------------------------------------------------
\center{Пример класса}
\vspace{15pt}
\begin{lstlisting}
	class Simple(ParentClass):
		"class documentation"

		def method(self, val):
			"method documentation"
			self.some_field = val
			return val ** 0.3
\end{lstlisting}
\newpage

%-------------------------------------------------------------------------------
\center{Нет инкапсуляции}
\begin{itemize}
	\item "Принцип открытого кимоно" == 
		"мы не знаем как совместить инкапсуляцию 
		с остальными возможностями языка"
	\item Есть property, "скрытые поля" (но они предназначенны для другого)
	\item В отличии от Java всегда можно изменить поле на свойство 
			с сохранением совместимости
	\item Можно реализовать любой вид инкапсуляции динамической
	\item Документирование API vs чтение заголовков
	\item Ничего из этого не получило какого-нить распространения в питоне
	\item Реализуя сокрытие полей объекта вы 
		создаете проблемы многим библиотекам python
\end{itemize}
\newpage

%-------------------------------------------------------------------------------
\center{\lstinline!__init__!}
\begin{itemize}
	\item \lstinline!__init__! конструктор, вызывается 
		при создании экземпляра класса
	\item 
\end{itemize}
\vspace{15pt}
\begin{lstlisting}
	class A(object):
		def __init__(self, val):
			self.var = val
			print "A inited with value", val

	a = A(1) # A inited with value 1
	print a.var # 1
\end{lstlisting}
\newpage

%-------------------------------------------------------------------------------
\center{\lstinline!__del__!}
\begin{itemize}
	\item \lstinline!__del__! Должен вызываться перед удалением объекта 
		(и, обычно, вызывается достаточно предсказуемо)
	\item Если нет циклических ссылок
	\item Или объект не попал во фрейм, где произошла ошибка
	\item Использовать with вместо надежд на \_\_del\_\_
	\item \lstinline!def __del__(self):...!
\end{itemize}
\newpage

%-------------------------------------------------------------------------------
%level=3
\center{\lstinline!__new__!}
\begin{itemize}
	\item \lstinline!__new__! аналог перегрузки new в С++
	\item Классовый метод(автоматически), вызываемый для создания 
		нового экземпляра объекта, который затем будет проинициализирован 
		с помощью \lstinline!__init__!. classmethod использовать не надо.
	\item Получает те-же параметры, что и \lstinline!__init__!.
\end{itemize}
\vspace{15pt}
\begin{lstlisting}
	class X(object):
	    def __new__(cls, val):
	        print "{}.__new__({!r})".format(cls.__name__, val)
	        return object.__new__(cls, val)
	    
	    def __init__(self, val):
	        print "{}.__init__({!r})".format(self.__class__.__name__, val)

	X(1)
	#X.__new__(1)
	#X.__init__(1)
\end{lstlisting}

%-------------------------------------------------------------------------------
%level=3
\center{\lstinline!__new__!}
\begin{itemize}
	\item \lstinline!__new__! может вернуть объект другого типа
	\item Наверное, не самая лучшая идея
\end{itemize}
\vspace{15pt}
\begin{lstlisting}
	class A(object):
	    def __init__(self, x):
	    	pass

	class B(object):
	    def __init__(self, x, y):
	    	pass
	    def __new__(cls, x, y=None):
	        if y is None:
	            return A(x)
	        else:
	            return super(B, cls).__new__(cls, x, y)

	print B(1, 2) #<__main__.B at 0x...>
	print B(1) # <__main__.A at 0x...>	
\end{lstlisting}
\newpage

%-------------------------------------------------------------------------------
\center{Наследование}
TBD
\newpage

%-------------------------------------------------------------------------------
\center{Полиморфизм}
\begin{itemize}
	\item Все методы - виртуальные.
\end{itemize}
{
\Large
\vspace{15pt}
\begin{lstlisting}
	class A(object):
		def some_method(self):
			print "A.some_meth"

	class B(object):
		def some_method(self):
			print "B.some_meth"

	b = B(1) 
	# B inited with value 1
	# A inited with value 1
	b.double_var() # B double called
\end{lstlisting}
}
\newpage

%-------------------------------------------------------------------------------
\center{super}
{
\Large
\vspace{15pt}
\begin{lstlisting}
	class A(object):
		def __init__(self, val):
			self.var = val
			print "A inited with value", val
		def double_var(self):
			self.var *= 2

	class B(A):
		def __init__(self, val):
			print "B inited with value", val
			A.__init__(self, val)
		def double_var(self):
			self.var *= 2
			print "B double called"

	b = B(1) 
	# B inited with value 1
	# A inited with value 1
	b.double_var() 
	# B double called
\end{lstlisting}
}
\newpage

%-------------------------------------------------------------------------------
\center{super}
\begin{lstlisting}
	class A(object):
	    def draw(self, pt):
	        some_action()

	class B(A):
	    def draw(self, pt):
	    	#A.draw(self, pt)
	        super(B, self).draw(pt)
\end{lstlisting}
\newpage

%-------------------------------------------------------------------------------
%level=3
\center{super uncovered}
TBD
\newpage

%-------------------------------------------------------------------------------
%level=3
\center{Скрытие полей}
\begin{itemize}
	\item \lstinline!__xxxx! - "скрытые поля и методы" 
		- переименовываются для избежания пересечения имен
	\item \lstinline!A.__xxx! -> \lstinline!A._A__xxx!
	\item Не для инкапсуляции
\end{itemize}
\newpage

%-------------------------------------------------------------------------------
\center{Связанные и не связанные методы}
\begin{itemize}
	\item \lstinline!a = A()!, \lstinline!a.b(1) == A.b(a, 1)!
	\item \lstinline!A.b! несвязанный метод. \lstinline!A.b(1)! - ошибка, 
			Первым параметром должен идти экземпляр класса А. \lstinline!(A.b)(a, 1)! - ok
	\item \lstinline!a.b! - связанный метод, эквивалентен функции.
\end{itemize}
\vspace{15pt}
\begin{lstlisting}
	a = A()
	t = a.b
	t(1) # a.b(1)
\end{lstlisting}
\newpage

%-------------------------------------------------------------------------------
\center{Сортировка и сравнение}
DSU
\newpage

%-------------------------------------------------------------------------------
\center{Классовые и статические методы}
\begin{itemize}
	\item \lstinline!classmethod! превращяет метод в классовый, первым параметром вместо
		экземпляра такой метод получает класс и может быть вызван от класса
	\item \lstinline!staticmethod! превращяет метод в статический - обычная функция
\end{itemize}
\vspace{15pt}
\begin{lstlisting}
	class A(object):
		val = 12
		@classmethod
		def meth1(cls, x):
			return x + cls.val
		@staticmethod
		def meth2(x, y):
			return x + y

	A.meth1(1) == 13
	A().meth2(1,2) == 3 

	class B(A):
		val = 13

	B.meth1(1) == 14
\end{lstlisting}
\newpage

%-------------------------------------------------------------------------------
\center{Специальные методы - int}
\begin{itemize}
	\item \lstinline!__add__(self, obj) # self + obj!
	\item \lstinline!__radd__(self, obj) #  obj + self!
	\item \lstinline!__iadd__(self, obj) #  self += obj!
	\item \lstinline!__int__(self) # int(self)!
\end{itemize}
\newpage
%-------------------------------------------------------------------------------
%level=TBD
\center{Работа некоторых встроенных функций (протоколы встроенных функций)}
\begin{itemize}
	\item \lstinline!int(x) == x.__int__()!
	\item \lstinline!str(x) == x.__str__()!
	\item \lstinline!repr(x) == x.__repr__()!
	\item \lstinline!len(x) == x.__len__()!
	\item \lstinline!iter(x) == x.__iter__()!
	\item \lstinline!next(x) == x.next()! O\_o
	\item \lstinline!hex, oct, hash!
\end{itemize}
\newpage

%-------------------------------------------------------------------------------
% level=3
\center{Специальные методы - контейнер}
\begin{itemize}
	\item \lstinline!x.__getitem__(index) # x[index]!
	\item \lstinline!x.__setitem__(index, val) # x[index] = val!
	\item \lstinline!x.__delitem__(index) # del x[index]!
	\item ...
\end{itemize}
\newpage

%-------------------------------------------------------------------------------
\center{Специальные методы - доступ к атрибутам}
\begin{itemize}
	\item \lstinline!x.__getattribute__(name)!
	\item \lstinline!x.__getattr__(name)!
	\item \lstinline!x.__setattr__(name, val)!
	\item \lstinline!x.__delattr__(name)!
	\item \lstinline!getattr(x, name[, val])!
	\item \lstinline!setattr(x, name, val)!
	\item \lstinline!delattr(x, name)!
\end{itemize}
\newpage

%-------------------------------------------------------------------------------
\end{document}
