% python classes clides - containers and files
% (c) 2012 Kostiantyn Danylov aka koder 
% koder.mail@gmail.com
% distributed under CC-BY licence
% http://creativecommons.org/licenses/by/3.0/deed.en

\documentclass{article}
\input{files/lectures_env}
\input{files/python_cmds}
\begin{document}
\LARGE

%-------------------------------------------------------------------------------
\center{Контейнеры}
\begin{itemize}
	\item list == [...]
	\item tuple == (...)
	\item dict == \{a:b, ...\}
	\item set == \{a, b, ....\}
\end{itemize}
\newpage

%-------------------------------------------------------------------------------
\center{list – Список (Массив)}
\begin{itemize}
	\item Упорядоченное множество элементов, доступ по номеру
	\item \lstinline!var = [1, 2, 3]!
	\item Индексация \lstinline!arr[x]!
	\item Срезы 
			\lstinline!arr[frm:to:step]! \\
			\lstinline![arr[frm], arr[frm + step], ....., ]!
	\item Отрицательный индекс - отсчет от конца. x[-1]
	\item Отсутвие индекса - frm -> 0, to -> -1, step -> 1
	\item arr[::-1] - инверсия элементов
	\item arr[:] - копия
\end{itemize}
\newpage

%-------------------------------------------------------------------------------
\center{list – Список (Массив)}
{
\Huge
\begin{flushleft}
$x = [0_{-6}^{0}, 1_{-5}^{1}, 2_{-4}^{2}, 3_{-3}^{3}, 4_{-2}^{4}, 5_{-1}^{5}]$ \\
\vspace{0.5cm}
x[2] == 2 \hspace{2cm}[\textcolor{red}{0, 1,} 2, \textcolor{red}{3, 4, 5}] \\
\vspace{0.5cm}
x[-2] == 4 \hspace{2cm}[\textcolor{red}{0, 1, 2, 3,} 4, \textcolor{red}{5}] \\
\vspace{0.5cm}
x[2:] == [2, 3, 4, 5] \hspace{2cm}[\textcolor{red}{0, 1, }2, 3, 4, 5] \\
\vspace{0.5cm}
x[-2:] == [4, 5] \hspace{2cm}[\textcolor{red}{0, 1, 2, 3,} 4, 5] \\
\vspace{0.5cm}
x[1:-1] == [1, 2, 3, 4] \hspace{2cm}[\textcolor{red}{0,} 1, 2, 3, 4, \textcolor{red}{5}] \\
\vspace{0.5cm}
x[1:-1:2] == [1, 3] \hspace{2cm}[\textcolor{red}{0,} 1, \textcolor{orange}{2,} 3, \textcolor{orange}{4,} \textcolor{red}{5}] \\
\vspace{0.5cm}
x[::-1] == [5, 4, 3, 2, 1, 0] \\
\end{flushleft}
}
\newpage

%-------------------------------------------------------------------------------
\center{list – Операции нам элементам и срезам}
\vspace{15pt}
\begin{lstlisting}
	x = [3, 4, 5, 6]
	x[::2] = [2, 2]  # x == [2, 4, 2, 6]
	x[::2] = 2 # error
	del x[1] # x == [3, 5, 6]
	x = [1, None, True, ["123", 2.4]]
	[1, 2, 3] + ["a", "b"] # [1, 2, 3, "a", "b"]
\end{lstlisting}
\newpage

%-------------------------------------------------------------------------------
\center{Методы списка}
\Large{
\vspace{15pt}
\begin{lstlisting}
	# arr.append(val)
	[1, 2].append(3) == [1, 2, 3]

	# arr.extend(arr2)
	[1, 2].extend([2, 3]) == [1, 2, 2, 3]

	# arr.pop()
	x = [1, 2]
	x.pop() == 2
	print x # [1]

	# arr.insert(pos, val)
	[1, 2].insert(0, "abc") == ["abc", 1, 2]

	[1, 2].index(2) == 1
	[1, 2].reverse() == [2, 1]
	[1, 2, 4, 1, 2, 4, 1, 1].count(1) == 4
	x = [1, 3, 2]
	x.remove(1) # x == [3, 2]
	x.sort() # x == [2, 3]
\end{lstlisting}
}
\newpage

%-------------------------------------------------------------------------------
\center{Изменяемые типы (ссылочные)}
\vspace{15pt}
\begin{lstlisting}
	x = [1, 2, 3]
	y = x
	y.append(1)
	print x => [1, 2, 3, 1]
\end{lstlisting}
\newpage

%-------------------------------------------------------------------------------
\center{Изменяемые типы (ссылочные)}
\vspace{15pt}
\begin{lstlisting}
	x = [["1"], "2"]
	y = x
\end{lstlisting}
\includegraphics[scale=0.6]{images/refs_1.pdf}

\vspace{15pt}
\begin{lstlisting}
	x = [["1"], "2"]
	y = x[:]
\end{lstlisting}
\includegraphics[scale=0.6]{images/refs_2.pdf}

\newpage

\vspace{15pt}
\begin{lstlisting}
	import copy
	x = [["1"], "2"]
	y = copy.deepcopy(x)
\end{lstlisting}
\includegraphics[scale=0.6]{images/refs_3.pdf}

\newpage

%-------------------------------------------------------------------------------
\center{Сортировка}
\begin{itemize}
	\item sort() сортировка на месте, sorted - возвращает копию
	\item sort
	\item Не надо сортировать неоднородные контейнеры типы - результат не определен
		По больше части - получится что-то, но иногда -
		\lstinline!['x', '\xf0', u'x'].sort()! - UnicodeDecodeError
\end{itemize}
\newpage

%-------------------------------------------------------------------------------
\center{tuple – кортеж}
\begin{itemize}
	\item Константный список ( но можно изменять элементы, если они не константные)
\end{itemize}
\vspace{15pt}
\begin{lstlisting}
	tpl = (1, 2)
	tpl = 1,2
	tpl[1] = 3 # error
	tpl = (1, [2, 3, 4])
	tpl[1].append(1) => (1, [2, 3, 4, 1])
	(1) == 1
	(1,) == (1,)
	range(x) == (0, ..., x – 1)
	range(x, y, z) == range(x)[:y:z]
\end{lstlisting}
\newpage

%-------------------------------------------------------------------------------
\center{dict - словарь}
\begin{itemize}
	\item Набор пар (ключ, значение), с быстрым поиском по ключу
	\lstinline$x = {1:2, "3":4}$
	\item Только константные ключи (tuple - ok)
	\item Элементы неупорядоченны
	\item Нет срезов
\end{itemize}
\vspace{15pt}
\begin{lstlisting}
	x[1] == 2
	x[2] #error
	1 in x == True
	x[17] = True
	# x = {1:2, "3":4, 17:True}
\end{lstlisting}
\newpage

%-------------------------------------------------------------------------------
\center{dict – Словарь}
\vspace{15pt}
\begin{lstlisting}
	x = {1:2, "3":"4"}
	dict(a=1, b=2) == {"a":1, "b":2}
	x.items() == [(1, 2), ("3", "4")]
	x.values() == [2, "4"]
	x.keys() == [1, "3"]
	x.copy() == {1:2, "3":"4"}
	x.setdefault(key, val) == val # if key not in x else x[key]
	x.get(5, None) == None # if 5 not in x else x[5]
	x.clear() # {}
	x.update(y)
	dict.fromkeys(keys, val) # {key[0]:val, key[1]:val, ..} default val is None
\end{lstlisting}
\newpage

%-------------------------------------------------------------------------------
\center{set - множество}
\begin{itemize}
	\item Множество элементов с быстрым поиском и операциями
\end{itemize}
\vspace{15pt}
\begin{lstlisting}
	x = {1, 2} 
	y = set([2, "a"]) # y == {2, "a"}
	x & y == x.intersection(y) == {2}
	x – y == x.difference(y) == {1}
	x | y == x.union(y) == {1, 2, "a"}
	x.issubset(y) # ....


	set(1, 2, 3) # error
	set("abcd") == set(["a", "b", "c", "d"])
\end{lstlisting}
\newpage

%-------------------------------------------------------------------------------
%level=3
\center{Особенности поведения set \& dict}
\begin{itemize}
	\item Ключи сравниваются с помощью hash, затем ==
	\item \lstinline!hash(2.0) == 2, hash(2) == 2, 2.0 == 2!
	\item Для пользовательских объектов hash \& == можно перегрузить
\end{itemize}
\begin{lstlisting}
	{2.0: "ccc", 2: "dd"} == {2.0: "ccc"}
	set([2]) | set([2.0]) == set([2])
	set([2.0]) | set([2]) == set([2.0])
	set([2]) == set([2.0])
\end{lstlisting}
\newpage

%-------------------------------------------------------------------------------
\center{Общие операции над контейнерами}
\begin{itemize}
	\item list, tuple, set
	\item len длинна 
	\item str.join \lstinline!", ".join(["1", "2", "3"]) == "1, 2, 3"! 
	\item in проверка включения элемента
	\item dict из [(key1, val1), (key2, val2), …]
\end{itemize}
\newpage

%-------------------------------------------------------------------------------
\center{Циклические контейнеры}
\vspace{15pt}
\begin{lstlisting}
	a = []
	a.append(a)
\end{lstlisting}
\newpage

%-------------------------------------------------------------------------------
\center{Файлы}
\begin{itemize}
	\item Абстракция для источников или приемников данных
	\item Тестовые и бинарные
	\item Можно писать и читать (+os.ioctl)
\end{itemize}
\vspace{15pt}
\begin{lstlisting}
    fd = open(path, mode)
    mode in {"r", "w", "r+", "a", 
             "rb", "wb", "rb+", "ab"}
\end{lstlisting}
\newpage

%-------------------------------------------------------------------------------
\center{Файлы}
\vspace{15pt}
\begin{lstlisting}
	import os
	fd.read(size) # data str
	fd.write("data")
	fd.seek(pos, frm)
	
	# frm in {os.SEEK_SET, os.SEEK_CUR, os.SEEK_END}
	
	fd.read() # till the end
	fd.readline() # untill "\n"
\end{lstlisting}
\newpage
%-------------------------------------------------------------------------------
\center{AA}
\begin{itemize}
	\item TBD
\end{itemize}
\newpage

%-------------------------------------------------------------------------------
\end{document}
