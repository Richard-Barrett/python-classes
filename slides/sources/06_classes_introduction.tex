% python classes slides - classes_introduction
% (c) 2012 Kostiantyn Danylov aka koder 
% koder.mail@gmail.com
% distributed under CC-BY licence
% http://creativecommons.org/licenses/by/3.0/deed.en

\documentclass{article}
\input{files/lectures_env}
\input{files/python_cmds}
\begin{document}
\LARGE

%-------------------------------------------------------------------------------
\begin{center} Рациональные числа - задача \end{center}
\begin{itemize}
    \item Сделать набор функций для работы с простыми дробями.
    \item Дробь хранится в виде [r\_type, numer, denom]
    \item r\_type - тип дроби: "basic" или "auto\_simpl"
    \item При операциях с "auto\_simpl" в отличии от "basic" нужно
          сокращать числитель и знаменатель на НОД
    \item Сделать поддержку функций add, sub, mul, tostr
\end{itemize}
Алгоритм евклида, 
$$
    a \geq b, MCD(a, b) = \left\{ 
    \begin{array}{r}
        b,  a \div b = 0 \\
        MCD(b, a \div b)
    \end{array} \right.
$$

\newpage

%-------------------------------------------------------------------------------
\begin{center} Рациональные числа - API \end{center}
\begin{lstlisting}
    r1 = ['basic', 1, 3]
    r2 = ['basic', 1, 2]

    print tostr(r1) # 1/3

    r3 = sub(r2, r1)
    print tostr(r3) # 1/6

    r4 = add(r1, r1)
    print tostr(r4) # 2/6

    r5 = ['auto_simpl', r1[1], r1[2]]
    r6 = add(r5, r5)
    print tostr(r6) # 1/3
\end{lstlisting}
\newpage

%-------------------------------------------------------------------------------
\begin{center}Рациональные числа - процедурный стиль\end{center}
\begin{lstlisting}
    def tostr(x):
        return "{[1]}/{[2]}".format(x)

    def nod(x, y):
        x = abs(x)
        y = abs(y)
        return _nod(max(x, y), min(x, y))

    def _nod(x, y):
        if y == 0:
            return x
        return nod(y, x % y)

    def add(x, y):
        nd = x[2] * y[2]
        nn = x[1] * y[2] + x[2] * y[1]
        if x[0] == 'basic':
            return ['basic', nn, nd]
        cur_nod = nod(nn, nd)
        return ['auto_simpl', nn / cur_nod, nd / cur_nod]

    def sub(x, y):
        return add(x, [y[0], -y[1], y[2]])
\end{lstlisting}
\newpage

%-------------------------------------------------------------------------------
\begin{center} Процедурный стиль - анализ \end{center}
\begin{itemize}
    \item Добавление новых типов требует изменения функции add
    \item \lstinline!if x[0] == 'basic':! - ужасно
    \item Декомпозиция логики затруднена
    \item Перегрузка функций решает часть проблем, но только часть
    \item Один из вариантов решения - привязать функции к данным
\end{itemize}
\newpage

%-------------------------------------------------------------------------------
\begin{center} Рациональные числа - не совсем процедурный стиль \end{center}
\begin{lstlisting}
    def add_basic(x, y):
        nd = x['denom'] * y['denom']
        nn = x['num'] * y['denom'] + x['denom'] * y['num']
        res = x.copy()
        res['num'] = nn
        res['denom'] = nd
        return res
    def add_simplified(x, y):
        res = add_basic(x, y)
        cur_nod = nod(res['num'], res['denom'])
        res['num'] /= cur_nod
        res['denom'] /= cur_nod
        return res

    x1 = {'num':1, 'denom':2, 'add': add_basic}

    def add(x, y):
        return x['add'](x, y)
\end{lstlisting}
\newpage

%-------------------------------------------------------------------------------
\begin{center} Не совсем процедурный стиль - анализ \end{center}
\begin{itemize}
    \item Кода стало больше
    \item Его расширение упростилось - не нужно модифицировать функцию add,
          при добавлении нового типа
    \item Типовые теги стали менее нужны - тип это операции, которые есть у него
    \item Вместо \lstinline!func(x)! теперь \lstinline!x['func'](x)!. 
          Для упрощения вызова старая процедурная семантика оставлена,
          но внутри нее перенаправление на новый вызов
    \item Однако если нужно написать новую функцию для всех типов, то все 
          равно приходится использовать if/elif/elif/else. Только теги нужно 
          вернуть
    \item Каждый экземпляр содержит большое количество ссылок на одни и те же
          функции
    \item Решение - вынесение всех методов в отдельный словарь, который все 
          переменные данного типа используют совместно. Одновременно этот
          словарь становится типовым тегом
\end{itemize}
\newpage

%-------------------------------------------------------------------------------
\begin{center} Рациональные числа - совсем не процедурный стиль \end{center}
\begin{lstlisting}
    RationalNumber = {'add': add_basic, 
                      'sub': sub_basic}

    RationalNumberSimpl = {'add': add_simplified, 
                           'sub': sub_simplified}

    x1 = {'num':1, 'denom':2, 
          '__class__': RationalNumber}

    x2 = {'num':1, 'denom':2, 
          '__class__': RationalNumberSimpl}

    def add(x, y):
        return x['__class__']['add'](x, y)
\end{lstlisting}

\begin{itemize}
    \item Шаблон, использованный в функции add часто используется в 
          python и позволяет имитировать перегрузку функций
    \item Именно так и устроено ООП в питоне внутри
\end{itemize}
\newpage

%-------------------------------------------------------------------------------
\begin{center} Рациональные числа - классы \end{center}
\begin{lstlisting}
    class BasicRational(object):
        "basic rational number"

        def __init__(self, num, denom):
            self.num = num
            self.denom = denom

        def add(self, y):
            nd = self.denom * y.denom
            nn = self.num * y.denom + y.num * self.denom
            return BasicRational(nn, nd)

        def neg(self):
            return BasicRational(-self.num, self.denom)

        def sub(self, y):
            return self.add(y.neg())

        def tostr(self):
            return "{}/{}".format(self.num, self.denom)

    class AutoSimpl(BasicRational):
        "Auto simplified rational number"

        def add(self, y):
            res = BasicRational.add(self, y)
            cur_nod = nod(res.num, res.denom)
            res.num /= cur_nod
            res.denom /= cur_nod
            return res
\end{lstlisting}
\newpage

%-------------------------------------------------------------------------------
\begin{center} Рациональные числа - классы \end{center}
\begin{lstlisting}
    class AutoSimpl(BasicRational):
        "Auto simplified rational number"
    
        def __init__(self, num, denom):
            cur_nod = nod(num, denom)
            self.num = num / cur_nod
            self.denom = denom / cur_nod
\end{lstlisting}
\newpage

%-------------------------------------------------------------------------------
\begin{center} Рациональные числа - интерфейсы питона \end{center}
\begin{lstlisting}
    class BasicRational(object):
        "basic rational number"

        def __init__(self, num, denom):
            self.num = num
            self.denom = denom

        def __add__(self, y):
            nd = x[2] * y[2]
            nn = x[1] * y[2] + x[2] * y[1]
            return self.__class__(nn, nd)

        def __neg__(self):
            return self.__class__(-nn, nd)

        def __sub__(self, y):
            return self.add(y.neg())

        def __str__(self):
            return "{[1]}/{[2]}".format(x)

        def __repr__(self):
            return str(self)

    b1 = AutoSimpl(1, 2)
    b2 = AutoSimpl(1, 3)
    b3 = b2 - b1 - b1
    print b1, b2, b3

\end{lstlisting}
\newpage

%-------------------------------------------------------------------------------
\begin{center} ООП vs Процедурный стиль \end{center}
\begin{itemize}
    \item (-) Часто больше кода
    \item (-) Усложняет язык
    \item (+) Уменьшает пересечение имен
    \item (+) Код лучше структурирован
    \item (+) Избавляет от ручной проверки типов
    \item (+) Упрощается расширение
    \item (+) Более высокий уровень абстракции упрощает построение программы
              путем выделения стандартных шаблонов проектирования
    \item (+) Многие из идей ООП имеют прямую поддержку в языке
\end{itemize}
\newpage

%-------------------------------------------------------------------------------
\begin{center} Python ООП vs Процедурный стиль \end{center}
\begin{itemize}
    \item Возможность перегрузки функций
    \item Возможность перегрузки операторов
\end{itemize}
\newpage

%-------------------------------------------------------------------------------
\end{document}
