ДЗ

В файле 00_external_materials.pdf есть ссылки на дополнительные материалы для обучения питону.

1) Посмотрите следующие лекции:
регулярные выражения: http://www.youtube.com/watch?v=kWyoYtvJpe4
обработка юникода: http://www.youtube.com/watch?v=sgHbC6udIqc

2) Python MOTW - http://www.doughellmann.com/PyMOTW/
отличная дополнительная документация с примерами по стандартной библиотеке питона

3) Внимательно ознакомтесь с содержимым модулей os, os.path и sys - их прийдется применять достаточно часто

4) Оформление кода

Для построения своих .py файлов используйте следующий шаблон:

    #!/usr/bin/env python
    # -*- coding:utf8 -*-
    "документация на файл"

    # ваш код 

    # юнит-тесты


    def main(argv=None):
        "main"
        if argv is None:
            argv = sys.argv
        # тут запускаем юнит-тесты
        return 0

    if __name__ == "__main__":
        exit(main(sys.argv))
    

Смысл некоторых частей я поясню позже.

5) Правила для дз

* eval, exec и подобные средства запрещенны
* Сторонние библиотеки использовать нельзя без явного указания
* К коду должны быть написанны юнит-тесты.

Задачи:

1) Написать функцию factorize, которая генерирует все простые делители у переданного числа.
    list(factorize(15)) == [3, 5]
    list(factorize(16)) == [2, 2, 2, 2]

2) Написать функцию get_hrefs, которая принимает на вход html файл и генерирует 
    все ссылки из него. Ссылка задается тегом <a href=".....".

3) Написать функцию file_difference, которая генерирует все отличия между двумя файлами.
    На выходе должна быть последовательность из пар (начальная позиция, конечная позиция),
    описывающих отличающиеся участки. Например
    f1 = "xxxxyyyytttt"
    f2 = "xxxxttttyyyy"
    Должна сгенерировать одну пару (4, 12).

4) Написать анализатор вывода windump(windows - http://www.winpcap.org/windump) или tcpdump(linux).
Windump/tcpdump собирают информацию о проходящих по сети пакетах и записывают ее в 
тектовом виде(по умолчанию) в файл. Необходимо по переданному файлу, содержащему 
вывод выбранной программы получить следующие данные

   a) Суммарный объем траффика по отдельным протоколам (TCP/UDP/ICMP)
   b) С какими хостами был наибольший объем обмена данными (например 10 наиболее активных)

5) Используя модуль subprocess и код из задания 4) реализовать функцию, которая будет
запускать выбранный анализатор в фоне и печатать на экран указанную статистику каждые 30 секунд

6) Написать функцию bind, которая принимает функцию func и список параметров params1
   и возвращает функцию, при вызове которой со списком параметров params2 вызывается
   func c объединенным списком параметров params1 + params2. Именованные параметры не нужно 
   поддерживать. Например:

   func2 = bind(func, 1, 2, 3)

   func2(12) == func(1, 2, 3, 12)

7) Написать функции, умеющуе сериализовать и десериализовать следующие типы данных:
    list, int, str, dict и все их комбинации. Например такое значение
    {'a':1, 'b':[1,2,3,['3']], 4:7}. Длинные целые поддерживать не надо.
    Сериализаций называется превращение значения в строку, представление которой не 
    зависит от аппаратных особенностей компьютера. serialize должна возвращать строку,
    вызов deserialize от которой вернет значение, равное значению, переданному в 
    serialize. Нельзя использовать eval/pickle/marshal и прочие готовые решения.
    Строки внутри передаваемого значения могут содержать любые символы (например
    '\x00', '{', '}', '[', ']', '(', ')', etc). Не стоит для преобразования 
    полагаться на встроенное преобразование объектов в строку с помошью функций 
    str/repr. 

    Необходимые модули: struct. 

8) Найти 10 самых больших файлой в дереве, начинающемся с указанной папки.
Необходимые функции: os.stat, os.walk.

9) Написать функцию, которая получает словарь вида 
{str: str or None} и строку(root) и создает на диске дерево файлов следующиего вида - 
для каждого элемента в словаре, у которого значение не None - создается файл 
с путем os.path.join(root, "ключ елемента") и в него записывается значение элемента.
Если значение None - то по аналогичному пути создается директория.
пример:

вызов create_tree("/tmp/test_dir", {'a':None, 'b/c':'xxxx', 'm/t/y/u':None})
создаст пустые папки '/tmp/test_dir/a' и '/tmp/test_dir/m/t/y/u'
и файл "/tmp/test_dir/b/c", содержащий 'xxxx'.



